(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
(function(){
  var i$, ref$, len$, module;
  if (typeof global != 'undefined' && global) {
    import$(global, require('prelude-ls'));
  }
  angular.module("dsc", ["ngRoute", "ngResource", "LocalStorageModule", "angucomplete-alt", "ui.grid", "ui.grid.autoResize", "ui.grid.saveState", "ngMask"]).filter('percentage', function($filter){
    return function(input, decimals){
      decimals == null && (decimals = 0);
      return $filter('number')(input * 100, decimals) + '%';
    };
  });
  require('./app/routes');
  require('./app/services/storage-service');
  require('./app/services/external-data-service');
  require('./app/services/data-export-service');
  require('./app/services/notification-service');
  require('./app/main-controller');
  (function(){
    require('./modules/armor-finder/main.js');require('./modules/guide/main.js');require('./modules/items/main.js');require('./modules/pc/main.js');require('./modules/tracker/main.js');require('./modules/weapon-finder/main.js');
  });
  for (i$ = 0, len$ = (ref$ = ['tracker', 'items', 'pc', 'weapon-finder', 'armor-finder']).length; i$ < len$; ++i$) {
    module = ref$[i$];
    require("./modules/" + module + "/main.js");
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./app/main-controller":8,"./app/routes":9,"./app/services/data-export-service":10,"./app/services/external-data-service":11,"./app/services/notification-service":12,"./app/services/storage-service":13,"./modules/armor-finder/main.js":17,"./modules/guide/main.js":20,"./modules/items/main.js":26,"./modules/pc/main.js":31,"./modules/tracker/main.js":35,"./modules/weapon-finder/main.js":40,"prelude-ls":7}],2:[function(require,module,exports){
// Generated by LiveScript 1.4.0
var apply, curry, flip, fix, over, memoize, slice$ = [].slice, toString$ = {}.toString;
apply = curry$(function(f, list){
  return f.apply(null, list);
});
curry = function(f){
  return curry$(f);
};
flip = curry$(function(f, x, y){
  return f(y, x);
});
fix = function(f){
  return function(g){
    return function(){
      return f(g(g)).apply(null, arguments);
    };
  }(function(g){
    return function(){
      return f(g(g)).apply(null, arguments);
    };
  });
};
over = curry$(function(f, g, x, y){
  return f(g(x), g(y));
});
memoize = function(f){
  var memo;
  memo = {};
  return function(){
    var args, key, arg;
    args = slice$.call(arguments);
    key = (function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = args).length; i$ < len$; ++i$) {
        arg = ref$[i$];
        results$.push(arg + toString$.call(arg).slice(8, -1));
      }
      return results$;
    }()).join('');
    return memo[key] = key in memo
      ? memo[key]
      : f.apply(null, args);
  };
};
module.exports = {
  curry: curry,
  flip: flip,
  fix: fix,
  apply: apply,
  over: over,
  memoize: memoize
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{}],3:[function(require,module,exports){
// Generated by LiveScript 1.4.0
var each, map, compact, filter, reject, partition, find, head, first, tail, last, initial, empty, reverse, unique, uniqueBy, fold, foldl, fold1, foldl1, foldr, foldr1, unfoldr, concat, concatMap, flatten, difference, intersection, union, countBy, groupBy, andList, orList, any, all, sort, sortWith, sortBy, sum, product, mean, average, maximum, minimum, maximumBy, minimumBy, scan, scanl, scan1, scanl1, scanr, scanr1, slice, take, drop, splitAt, takeWhile, dropWhile, span, breakList, zip, zipWith, zipAll, zipAllWith, at, elemIndex, elemIndices, findIndex, findIndices, toString$ = {}.toString, slice$ = [].slice;
each = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    f(x);
  }
  return xs;
});
map = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    results$.push(f(x));
  }
  return results$;
});
compact = function(xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (x) {
      results$.push(x);
    }
  }
  return results$;
};
filter = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      results$.push(x);
    }
  }
  return results$;
});
reject = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!f(x)) {
      results$.push(x);
    }
  }
  return results$;
});
partition = curry$(function(f, xs){
  var passed, failed, i$, len$, x;
  passed = [];
  failed = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    (f(x) ? passed : failed).push(x);
  }
  return [passed, failed];
});
find = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      return x;
    }
  }
});
head = first = function(xs){
  return xs[0];
};
tail = function(xs){
  if (!xs.length) {
    return;
  }
  return xs.slice(1);
};
last = function(xs){
  return xs[xs.length - 1];
};
initial = function(xs){
  if (!xs.length) {
    return;
  }
  return xs.slice(0, -1);
};
empty = function(xs){
  return !xs.length;
};
reverse = function(xs){
  return xs.concat().reverse();
};
unique = function(xs){
  var result, i$, len$, x;
  result = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!in$(x, result)) {
      result.push(x);
    }
  }
  return result;
};
uniqueBy = curry$(function(f, xs){
  var seen, i$, len$, x, val, results$ = [];
  seen = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    val = f(x);
    if (in$(val, seen)) {
      continue;
    }
    seen.push(val);
    results$.push(x);
  }
  return results$;
});
fold = foldl = curry$(function(f, memo, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    memo = f(memo, x);
  }
  return memo;
});
fold1 = foldl1 = curry$(function(f, xs){
  return fold(f, xs[0], xs.slice(1));
});
foldr = curry$(function(f, memo, xs){
  var i$, x;
  for (i$ = xs.length - 1; i$ >= 0; --i$) {
    x = xs[i$];
    memo = f(x, memo);
  }
  return memo;
});
foldr1 = curry$(function(f, xs){
  return foldr(f, xs[xs.length - 1], xs.slice(0, -1));
});
unfoldr = curry$(function(f, b){
  var result, x, that;
  result = [];
  x = b;
  while ((that = f(x)) != null) {
    result.push(that[0]);
    x = that[1];
  }
  return result;
});
concat = function(xss){
  return [].concat.apply([], xss);
};
concatMap = curry$(function(f, xs){
  var x;
  return [].concat.apply([], (function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(f(x));
    }
    return results$;
  }()));
});
flatten = function(xs){
  var x;
  return [].concat.apply([], (function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (toString$.call(x).slice(8, -1) === 'Array') {
        results$.push(flatten(x));
      } else {
        results$.push(x);
      }
    }
    return results$;
  }()));
};
difference = function(xs){
  var yss, results, i$, len$, x, j$, len1$, ys;
  yss = slice$.call(arguments, 1);
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
      ys = yss[j$];
      if (in$(x, ys)) {
        continue outer;
      }
    }
    results.push(x);
  }
  return results;
};
intersection = function(xs){
  var yss, results, i$, len$, x, j$, len1$, ys;
  yss = slice$.call(arguments, 1);
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
      ys = yss[j$];
      if (!in$(x, ys)) {
        continue outer;
      }
    }
    results.push(x);
  }
  return results;
};
union = function(){
  var xss, results, i$, len$, xs, j$, len1$, x;
  xss = slice$.call(arguments);
  results = [];
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    for (j$ = 0, len1$ = xs.length; j$ < len1$; ++j$) {
      x = xs[j$];
      if (!in$(x, results)) {
        results.push(x);
      }
    }
  }
  return results;
};
countBy = curry$(function(f, xs){
  var results, i$, len$, x, key;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    key = f(x);
    if (key in results) {
      results[key] += 1;
    } else {
      results[key] = 1;
    }
  }
  return results;
});
groupBy = curry$(function(f, xs){
  var results, i$, len$, x, key;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    key = f(x);
    if (key in results) {
      results[key].push(x);
    } else {
      results[key] = [x];
    }
  }
  return results;
});
andList = function(xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!x) {
      return false;
    }
  }
  return true;
};
orList = function(xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (x) {
      return true;
    }
  }
  return false;
};
any = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      return true;
    }
  }
  return false;
});
all = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!f(x)) {
      return false;
    }
  }
  return true;
});
sort = function(xs){
  return xs.concat().sort(function(x, y){
    if (x > y) {
      return 1;
    } else if (x < y) {
      return -1;
    } else {
      return 0;
    }
  });
};
sortWith = curry$(function(f, xs){
  return xs.concat().sort(f);
});
sortBy = curry$(function(f, xs){
  return xs.concat().sort(function(x, y){
    if (f(x) > f(y)) {
      return 1;
    } else if (f(x) < f(y)) {
      return -1;
    } else {
      return 0;
    }
  });
});
sum = function(xs){
  var result, i$, len$, x;
  result = 0;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    result += x;
  }
  return result;
};
product = function(xs){
  var result, i$, len$, x;
  result = 1;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    result *= x;
  }
  return result;
};
mean = average = function(xs){
  var sum, i$, len$, x;
  sum = 0;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    sum += x;
  }
  return sum / xs.length;
};
maximum = function(xs){
  var max, i$, ref$, len$, x;
  max = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (x > max) {
      max = x;
    }
  }
  return max;
};
minimum = function(xs){
  var min, i$, ref$, len$, x;
  min = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (x < min) {
      min = x;
    }
  }
  return min;
};
maximumBy = curry$(function(f, xs){
  var max, i$, ref$, len$, x;
  max = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (f(x) > f(max)) {
      max = x;
    }
  }
  return max;
});
minimumBy = curry$(function(f, xs){
  var min, i$, ref$, len$, x;
  min = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (f(x) < f(min)) {
      min = x;
    }
  }
  return min;
});
scan = scanl = curry$(function(f, memo, xs){
  var last, x;
  last = memo;
  return [memo].concat((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(last = f(last, x));
    }
    return results$;
  }()));
});
scan1 = scanl1 = curry$(function(f, xs){
  if (!xs.length) {
    return;
  }
  return scan(f, xs[0], xs.slice(1));
});
scanr = curry$(function(f, memo, xs){
  xs = xs.concat().reverse();
  return scan(f, memo, xs).reverse();
});
scanr1 = curry$(function(f, xs){
  if (!xs.length) {
    return;
  }
  xs = xs.concat().reverse();
  return scan(f, xs[0], xs.slice(1)).reverse();
});
slice = curry$(function(x, y, xs){
  return xs.slice(x, y);
});
take = curry$(function(n, xs){
  if (n <= 0) {
    return xs.slice(0, 0);
  } else {
    return xs.slice(0, n);
  }
});
drop = curry$(function(n, xs){
  if (n <= 0) {
    return xs;
  } else {
    return xs.slice(n);
  }
});
splitAt = curry$(function(n, xs){
  return [take(n, xs), drop(n, xs)];
});
takeWhile = curry$(function(p, xs){
  var len, i;
  len = xs.length;
  if (!len) {
    return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
    i += 1;
  }
  return xs.slice(0, i);
});
dropWhile = curry$(function(p, xs){
  var len, i;
  len = xs.length;
  if (!len) {
    return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
    i += 1;
  }
  return xs.slice(i);
});
span = curry$(function(p, xs){
  return [takeWhile(p, xs), dropWhile(p, xs)];
});
breakList = curry$(function(p, xs){
  return span(compose$(p, not$), xs);
});
zip = curry$(function(xs, ys){
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (i === len) {
      break;
    }
    result.push([x, ys[i]]);
  }
  return result;
});
zipWith = curry$(function(f, xs, ys){
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (i === len) {
      break;
    }
    result.push(f(x, ys[i]));
  }
  return result;
});
zipAll = function(){
  var xss, minLength, i$, len$, xs, ref$, i, lresult$, j$, results$ = [];
  xss = slice$.call(arguments);
  minLength = undefined;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
    i = i$;
    lresult$ = [];
    for (j$ = 0, len$ = xss.length; j$ < len$; ++j$) {
      xs = xss[j$];
      lresult$.push(xs[i]);
    }
    results$.push(lresult$);
  }
  return results$;
};
zipAllWith = function(f){
  var xss, minLength, i$, len$, xs, ref$, i, results$ = [];
  xss = slice$.call(arguments, 1);
  minLength = undefined;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
    i = i$;
    results$.push(f.apply(null, (fn$())));
  }
  return results$;
  function fn$(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xss).length; i$ < len$; ++i$) {
      xs = ref$[i$];
      results$.push(xs[i]);
    }
    return results$;
  }
};
at = curry$(function(n, xs){
  if (n < 0) {
    return xs[xs.length + n];
  } else {
    return xs[n];
  }
});
elemIndex = curry$(function(el, xs){
  var i$, len$, i, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (x === el) {
      return i;
    }
  }
});
elemIndices = curry$(function(el, xs){
  var i$, len$, i, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (x === el) {
      results$.push(i);
    }
  }
  return results$;
});
findIndex = curry$(function(f, xs){
  var i$, len$, i, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (f(x)) {
      return i;
    }
  }
});
findIndices = curry$(function(f, xs){
  var i$, len$, i, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (f(x)) {
      results$.push(i);
    }
  }
  return results$;
});
module.exports = {
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  partition: partition,
  find: find,
  head: head,
  first: first,
  tail: tail,
  last: last,
  initial: initial,
  empty: empty,
  reverse: reverse,
  difference: difference,
  intersection: intersection,
  union: union,
  countBy: countBy,
  groupBy: groupBy,
  fold: fold,
  fold1: fold1,
  foldl: foldl,
  foldl1: foldl1,
  foldr: foldr,
  foldr1: foldr1,
  unfoldr: unfoldr,
  andList: andList,
  orList: orList,
  any: any,
  all: all,
  unique: unique,
  uniqueBy: uniqueBy,
  sort: sort,
  sortWith: sortWith,
  sortBy: sortBy,
  sum: sum,
  product: product,
  mean: mean,
  average: average,
  concat: concat,
  concatMap: concatMap,
  flatten: flatten,
  maximum: maximum,
  minimum: minimum,
  maximumBy: maximumBy,
  minimumBy: minimumBy,
  scan: scan,
  scan1: scan1,
  scanl: scanl,
  scanl1: scanl1,
  scanr: scanr,
  scanr1: scanr1,
  slice: slice,
  take: take,
  drop: drop,
  splitAt: splitAt,
  takeWhile: takeWhile,
  dropWhile: dropWhile,
  span: span,
  breakList: breakList,
  zip: zip,
  zipWith: zipWith,
  zipAll: zipAll,
  zipAllWith: zipAllWith,
  at: at,
  elemIndex: elemIndex,
  elemIndices: elemIndices,
  findIndex: findIndex,
  findIndices: findIndices
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}
function compose$() {
  var functions = arguments;
  return function() {
    var i, result;
    result = functions[0].apply(this, arguments);
    for (i = 1; i < functions.length; ++i) {
      result = functions[i](result);
    }
    return result;
  };
}
function not$(x){ return !x; }
},{}],4:[function(require,module,exports){
// Generated by LiveScript 1.4.0
var max, min, negate, abs, signum, quot, rem, div, mod, recip, pi, tau, exp, sqrt, ln, pow, sin, tan, cos, asin, acos, atan, atan2, truncate, round, ceiling, floor, isItNaN, even, odd, gcd, lcm;
max = curry$(function(x$, y$){
  return x$ > y$ ? x$ : y$;
});
min = curry$(function(x$, y$){
  return x$ < y$ ? x$ : y$;
});
negate = function(x){
  return -x;
};
abs = Math.abs;
signum = function(x){
  if (x < 0) {
    return -1;
  } else if (x > 0) {
    return 1;
  } else {
    return 0;
  }
};
quot = curry$(function(x, y){
  return ~~(x / y);
});
rem = curry$(function(x$, y$){
  return x$ % y$;
});
div = curry$(function(x, y){
  return Math.floor(x / y);
});
mod = curry$(function(x$, y$){
  var ref$;
  return (((x$) % (ref$ = y$) + ref$) % ref$);
});
recip = (function(it){
  return 1 / it;
});
pi = Math.PI;
tau = pi * 2;
exp = Math.exp;
sqrt = Math.sqrt;
ln = Math.log;
pow = curry$(function(x$, y$){
  return Math.pow(x$, y$);
});
sin = Math.sin;
tan = Math.tan;
cos = Math.cos;
asin = Math.asin;
acos = Math.acos;
atan = Math.atan;
atan2 = curry$(function(x, y){
  return Math.atan2(x, y);
});
truncate = function(x){
  return ~~x;
};
round = Math.round;
ceiling = Math.ceil;
floor = Math.floor;
isItNaN = function(x){
  return x !== x;
};
even = function(x){
  return x % 2 === 0;
};
odd = function(x){
  return x % 2 !== 0;
};
gcd = curry$(function(x, y){
  var z;
  x = Math.abs(x);
  y = Math.abs(y);
  while (y !== 0) {
    z = x % y;
    x = y;
    y = z;
  }
  return x;
});
lcm = curry$(function(x, y){
  return Math.abs(Math.floor(x / gcd(x, y) * y));
});
module.exports = {
  max: max,
  min: min,
  negate: negate,
  abs: abs,
  signum: signum,
  quot: quot,
  rem: rem,
  div: div,
  mod: mod,
  recip: recip,
  pi: pi,
  tau: tau,
  exp: exp,
  sqrt: sqrt,
  ln: ln,
  pow: pow,
  sin: sin,
  tan: tan,
  cos: cos,
  acos: acos,
  asin: asin,
  atan: atan,
  atan2: atan2,
  truncate: truncate,
  round: round,
  ceiling: ceiling,
  floor: floor,
  isItNaN: isItNaN,
  even: even,
  odd: odd,
  gcd: gcd,
  lcm: lcm
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{}],5:[function(require,module,exports){
// Generated by LiveScript 1.4.0
var values, keys, pairsToObj, objToPairs, listsToObj, objToLists, empty, each, map, compact, filter, reject, partition, find;
values = function(object){
  var i$, x, results$ = [];
  for (i$ in object) {
    x = object[i$];
    results$.push(x);
  }
  return results$;
};
keys = function(object){
  var x, results$ = [];
  for (x in object) {
    results$.push(x);
  }
  return results$;
};
pairsToObj = function(object){
  var i$, len$, x, resultObj$ = {};
  for (i$ = 0, len$ = object.length; i$ < len$; ++i$) {
    x = object[i$];
    resultObj$[x[0]] = x[1];
  }
  return resultObj$;
};
objToPairs = function(object){
  var key, value, results$ = [];
  for (key in object) {
    value = object[key];
    results$.push([key, value]);
  }
  return results$;
};
listsToObj = curry$(function(keys, values){
  var i$, len$, i, key, resultObj$ = {};
  for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
    i = i$;
    key = keys[i$];
    resultObj$[key] = values[i];
  }
  return resultObj$;
});
objToLists = function(object){
  var keys, values, key, value;
  keys = [];
  values = [];
  for (key in object) {
    value = object[key];
    keys.push(key);
    values.push(value);
  }
  return [keys, values];
};
empty = function(object){
  var x;
  for (x in object) {
    return false;
  }
  return true;
};
each = curry$(function(f, object){
  var i$, x;
  for (i$ in object) {
    x = object[i$];
    f(x);
  }
  return object;
});
map = curry$(function(f, object){
  var k, x, resultObj$ = {};
  for (k in object) {
    x = object[k];
    resultObj$[k] = f(x);
  }
  return resultObj$;
});
compact = function(object){
  var k, x, resultObj$ = {};
  for (k in object) {
    x = object[k];
    if (x) {
      resultObj$[k] = x;
    }
  }
  return resultObj$;
};
filter = curry$(function(f, object){
  var k, x, resultObj$ = {};
  for (k in object) {
    x = object[k];
    if (f(x)) {
      resultObj$[k] = x;
    }
  }
  return resultObj$;
});
reject = curry$(function(f, object){
  var k, x, resultObj$ = {};
  for (k in object) {
    x = object[k];
    if (!f(x)) {
      resultObj$[k] = x;
    }
  }
  return resultObj$;
});
partition = curry$(function(f, object){
  var passed, failed, k, x;
  passed = {};
  failed = {};
  for (k in object) {
    x = object[k];
    (f(x) ? passed : failed)[k] = x;
  }
  return [passed, failed];
});
find = curry$(function(f, object){
  var i$, x;
  for (i$ in object) {
    x = object[i$];
    if (f(x)) {
      return x;
    }
  }
});
module.exports = {
  values: values,
  keys: keys,
  pairsToObj: pairsToObj,
  objToPairs: objToPairs,
  listsToObj: listsToObj,
  objToLists: objToLists,
  empty: empty,
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  partition: partition,
  find: find
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{}],6:[function(require,module,exports){
// Generated by LiveScript 1.4.0
var split, join, lines, unlines, words, unwords, chars, unchars, reverse, repeat, capitalize, camelize, dasherize;
split = curry$(function(sep, str){
  return str.split(sep);
});
join = curry$(function(sep, xs){
  return xs.join(sep);
});
lines = function(str){
  if (!str.length) {
    return [];
  }
  return str.split('\n');
};
unlines = function(it){
  return it.join('\n');
};
words = function(str){
  if (!str.length) {
    return [];
  }
  return str.split(/[ ]+/);
};
unwords = function(it){
  return it.join(' ');
};
chars = function(it){
  return it.split('');
};
unchars = function(it){
  return it.join('');
};
reverse = function(str){
  return str.split('').reverse().join('');
};
repeat = curry$(function(n, str){
  var result, i$;
  result = '';
  for (i$ = 0; i$ < n; ++i$) {
    result += str;
  }
  return result;
});
capitalize = function(str){
  return str.charAt(0).toUpperCase() + str.slice(1);
};
camelize = function(it){
  return it.replace(/[-_]+(.)?/g, function(arg$, c){
    return (c != null ? c : '').toUpperCase();
  });
};
dasherize = function(str){
  return str.replace(/([^-A-Z])([A-Z]+)/g, function(arg$, lower, upper){
    return lower + "-" + (upper.length > 1
      ? upper
      : upper.toLowerCase());
  }).replace(/^([A-Z]+)/, function(arg$, upper){
    if (upper.length > 1) {
      return upper + "-";
    } else {
      return upper.toLowerCase();
    }
  });
};
module.exports = {
  split: split,
  join: join,
  lines: lines,
  unlines: unlines,
  words: words,
  unwords: unwords,
  chars: chars,
  unchars: unchars,
  reverse: reverse,
  repeat: repeat,
  capitalize: capitalize,
  camelize: camelize,
  dasherize: dasherize
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{}],7:[function(require,module,exports){
// Generated by LiveScript 1.4.0
var Func, List, Obj, Str, Num, id, isType, replicate, prelude, toString$ = {}.toString;
Func = require('./Func.js');
List = require('./List.js');
Obj = require('./Obj.js');
Str = require('./Str.js');
Num = require('./Num.js');
id = function(x){
  return x;
};
isType = curry$(function(type, x){
  return toString$.call(x).slice(8, -1) === type;
});
replicate = curry$(function(n, x){
  var i$, results$ = [];
  for (i$ = 0; i$ < n; ++i$) {
    results$.push(x);
  }
  return results$;
});
Str.empty = List.empty;
Str.slice = List.slice;
Str.take = List.take;
Str.drop = List.drop;
Str.splitAt = List.splitAt;
Str.takeWhile = List.takeWhile;
Str.dropWhile = List.dropWhile;
Str.span = List.span;
Str.breakStr = List.breakList;
prelude = {
  Func: Func,
  List: List,
  Obj: Obj,
  Str: Str,
  Num: Num,
  id: id,
  isType: isType,
  replicate: replicate
};
prelude.each = List.each;
prelude.map = List.map;
prelude.filter = List.filter;
prelude.compact = List.compact;
prelude.reject = List.reject;
prelude.partition = List.partition;
prelude.find = List.find;
prelude.head = List.head;
prelude.first = List.first;
prelude.tail = List.tail;
prelude.last = List.last;
prelude.initial = List.initial;
prelude.empty = List.empty;
prelude.reverse = List.reverse;
prelude.difference = List.difference;
prelude.intersection = List.intersection;
prelude.union = List.union;
prelude.countBy = List.countBy;
prelude.groupBy = List.groupBy;
prelude.fold = List.fold;
prelude.foldl = List.foldl;
prelude.fold1 = List.fold1;
prelude.foldl1 = List.foldl1;
prelude.foldr = List.foldr;
prelude.foldr1 = List.foldr1;
prelude.unfoldr = List.unfoldr;
prelude.andList = List.andList;
prelude.orList = List.orList;
prelude.any = List.any;
prelude.all = List.all;
prelude.unique = List.unique;
prelude.uniqueBy = List.uniqueBy;
prelude.sort = List.sort;
prelude.sortWith = List.sortWith;
prelude.sortBy = List.sortBy;
prelude.sum = List.sum;
prelude.product = List.product;
prelude.mean = List.mean;
prelude.average = List.average;
prelude.concat = List.concat;
prelude.concatMap = List.concatMap;
prelude.flatten = List.flatten;
prelude.maximum = List.maximum;
prelude.minimum = List.minimum;
prelude.maximumBy = List.maximumBy;
prelude.minimumBy = List.minimumBy;
prelude.scan = List.scan;
prelude.scanl = List.scanl;
prelude.scan1 = List.scan1;
prelude.scanl1 = List.scanl1;
prelude.scanr = List.scanr;
prelude.scanr1 = List.scanr1;
prelude.slice = List.slice;
prelude.take = List.take;
prelude.drop = List.drop;
prelude.splitAt = List.splitAt;
prelude.takeWhile = List.takeWhile;
prelude.dropWhile = List.dropWhile;
prelude.span = List.span;
prelude.breakList = List.breakList;
prelude.zip = List.zip;
prelude.zipWith = List.zipWith;
prelude.zipAll = List.zipAll;
prelude.zipAllWith = List.zipAllWith;
prelude.at = List.at;
prelude.elemIndex = List.elemIndex;
prelude.elemIndices = List.elemIndices;
prelude.findIndex = List.findIndex;
prelude.findIndices = List.findIndices;
prelude.apply = Func.apply;
prelude.curry = Func.curry;
prelude.flip = Func.flip;
prelude.fix = Func.fix;
prelude.over = Func.over;
prelude.split = Str.split;
prelude.join = Str.join;
prelude.lines = Str.lines;
prelude.unlines = Str.unlines;
prelude.words = Str.words;
prelude.unwords = Str.unwords;
prelude.chars = Str.chars;
prelude.unchars = Str.unchars;
prelude.repeat = Str.repeat;
prelude.capitalize = Str.capitalize;
prelude.camelize = Str.camelize;
prelude.dasherize = Str.dasherize;
prelude.values = Obj.values;
prelude.keys = Obj.keys;
prelude.pairsToObj = Obj.pairsToObj;
prelude.objToPairs = Obj.objToPairs;
prelude.listsToObj = Obj.listsToObj;
prelude.objToLists = Obj.objToLists;
prelude.max = Num.max;
prelude.min = Num.min;
prelude.negate = Num.negate;
prelude.abs = Num.abs;
prelude.signum = Num.signum;
prelude.quot = Num.quot;
prelude.rem = Num.rem;
prelude.div = Num.div;
prelude.mod = Num.mod;
prelude.recip = Num.recip;
prelude.pi = Num.pi;
prelude.tau = Num.tau;
prelude.exp = Num.exp;
prelude.sqrt = Num.sqrt;
prelude.ln = Num.ln;
prelude.pow = Num.pow;
prelude.sin = Num.sin;
prelude.tan = Num.tan;
prelude.cos = Num.cos;
prelude.acos = Num.acos;
prelude.asin = Num.asin;
prelude.atan = Num.atan;
prelude.atan2 = Num.atan2;
prelude.truncate = Num.truncate;
prelude.round = Num.round;
prelude.ceiling = Num.ceiling;
prelude.floor = Num.floor;
prelude.isItNaN = Num.isItNaN;
prelude.even = Num.even;
prelude.odd = Num.odd;
prelude.gcd = Num.gcd;
prelude.lcm = Num.lcm;
prelude.VERSION = '1.1.2';
module.exports = prelude;
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{"./Func.js":2,"./List.js":3,"./Num.js":4,"./Obj.js":5,"./Str.js":6}],8:[function(require,module,exports){
(function(){
  var MainController;
  if (typeof angular != 'undefined' && angular !== null) {
    angular.module("dsc").controller("mainController", function($scope, $location, storageSvc, inventorySvc, notificationSvc, $route){
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t;
        return (t = typeof result)  == "object" || t == "function" ? result || child : child;
  })(MainController, arguments, function(){});
    });
  }
  MainController = (function(){
    MainController.displayName = 'MainController';
    var prototype = MainController.prototype, constructor = MainController;
    function MainController($scope, $location, _storageSvc, _inventorySvc, _notificationSvc, $route){
      var this$ = this;
      this.$scope = $scope;
      this.$location = $location;
      this._storageSvc = _storageSvc;
      this._inventorySvc = _inventorySvc;
      this._notificationSvc = _notificationSvc;
      this.$route = $route;
      this.dismissNotifications = bind$(this, 'dismissNotifications', prototype);
      this.resetProfile = bind$(this, 'resetProfile', prototype);
      this.resetProfileEditStatus = bind$(this, 'resetProfileEditStatus', prototype);
      this.deleteProfile = bind$(this, 'deleteProfile', prototype);
      this.switchProfile = bind$(this, 'switchProfile', prototype);
      this.addNewProfile = bind$(this, 'addNewProfile', prototype);
      this.profilesUpdated = bind$(this, 'profilesUpdated', prototype);
      this.wireUp = bind$(this, 'wireUp', prototype);
      this.loadAndInit = bind$(this, 'loadAndInit', prototype);
      this.setup = bind$(this, 'setup', prototype);
      this.$scope.profileEditStatus = null;
      this.$scope.newProfileName = '';
      this.$scope.currentProfile = '';
      this.$scope.$watch(function(){
        return this$.$location.path();
      }, function(it){
        this$.$scope.thisLocation = it;
      });
      this.setup();
      this.loadAndInit();
      this.wireUp();
    }
    prototype.setup = function(){
      this.$scope.menu = [
        {
          path: "/pc",
          name: "Stats & inventory"
        }, {
          path: "/armor-finder",
          name: "Armor finder"
        }, {
          path: "/weapon-finder",
          name: "Weapon & shield finder"
        }
      ];
    };
    prototype.loadAndInit = function(){
      this._storageSvc.switchToCurrentProfile();
      this.profilesUpdated();
    };
    prototype.wireUp = function(){
      var i$, ref$, len$, func;
      for (i$ = 0, len$ = (ref$ = ['addNewProfile', 'switchProfile', 'deleteProfile', 'resetProfile', 'resetProfileEditStatus', 'dismissNotifications']).length; i$ < len$; ++i$) {
        func = ref$[i$];
        this.$scope[func] = this[func];
      }
    };
    prototype.profilesUpdated = function(){
      this.$scope.profileList = this._storageSvc.loadProfileList();
      this.$scope.currentProfile = this._storageSvc.profileName;
      this.resetProfileEditStatus();
    };
    prototype.addNewProfile = function(){
      if (this.$scope.profileEditStatus === 'new') {
        this._storageSvc.addProfile(this.$scope.newProfileName);
        this.profilesUpdated();
        this.switchProfile();
      } else {
        this.$scope.profileEditStatus = 'new';
      }
    };
    prototype.switchProfile = function(){
      this._storageSvc.switchTo(this.$scope.currentProfile);
      this.$route.reload();
    };
    prototype.deleteProfile = function(){
      if (this.$scope.profileEditStatus === 'delete') {
        this._storageSvc.deleteProfile();
        this.profilesUpdated();
        this.switchProfile();
      } else {
        this.$scope.profileEditStatus = 'delete';
      }
    };
    prototype.resetProfileEditStatus = function(){
      this.$scope.profileEditStatus = null;
    };
    prototype.resetProfile = function(){
      this._storageSvc.clearProfile();
      this.switchProfile();
    };
    prototype.dismissNotifications = function(){
      this._notificationSvc.clear();
    };
    return MainController;
  }());
  if (typeof module != 'undefined' && module !== null) {
    module.exports = MainController;
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);

},{}],9:[function(require,module,exports){
(function(){
  angular.module("dsc").config(function($routeProvider){
    $routeProvider.when('/tracker/:area', {
      templateUrl: 'modules/tracker/tracker-view.html',
      controller: 'trackerController'
    }).when('/items', {
      templateUrl: 'modules/items/view.html',
      controller: 'ItemsController'
    }).when('/pc', {
      templateUrl: 'modules/pc/pc-view.html',
      controller: 'pcController'
    }).when('/weapon-finder', {
      templateUrl: 'modules/weapon-finder/weapon-finder-view.html',
      controller: 'weaponFinderController'
    }).when('/armor-finder', {
      templateUrl: 'modules/armor-finder/armor-finder-view.html',
      controller: 'armorFinderController'
    }).otherwise({
      redirectTo: '/tracker/asylum'
    });
  });
}).call(this);

},{}],10:[function(require,module,exports){
(function(){
  angular.module("dsc").service('dataExportSvc', function(){
    return {
      exportJson: function(data){
        window.open(encodeURI("data:application/json," + JSON.stringify(data)));
      },
      exportCsv: function(data){
        var firstLine, rows, i$, len$, item, row, key, value, output;
        firstLine = join(',')(
        keys(
        first(
        data)));
        rows = [];
        for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {
          item = data[i$];
          row = [];
          for (key in item) {
            value = item[key];
            if (typeof value === "string") {
              value = value.replace('"', '""').replace(/(\r\n|\n|\r)/g, '\\n');
              value = "\"" + value + "\"";
            }
            row.push(value);
          }
          row = join(',')(
          row);
          rows.push(row);
        }
        output = firstLine + "\n" + join("\n")(
        rows);
        window.open(encodeURI("data:text/plain," + output));
      }
    };
  });
}).call(this);

},{}],11:[function(require,module,exports){
(function(){
  var ExternalDataService;
  if (typeof angular != 'undefined' && angular !== null) {
    angular.module("dsc").service("externalDataSvc", function($resource, $q){
      return new ExternalDataService($resource, $q);
    });
  }
  ExternalDataService = (function(){
    ExternalDataService.displayName = 'ExternalDataService';
    var prototype = ExternalDataService.prototype, constructor = ExternalDataService;
    function ExternalDataService($resource, $q){
      this.$resource = $resource;
      this.$q = $q;
      this.loadJson = bind$(this, 'loadJson', prototype);
      this._cache = {};
    }
    /**
     * Load an external JSON resource and parse it into an array
     */
    prototype.loadJson = function(url, returnPromise){
      var task, ref$, this$ = this;
      returnPromise == null && (returnPromise = true);
      if (url == null || typeof url !== "string" || url.length < 1) {
        throw new Error("Invalid URL: [" + url + "]");
      }
      task = this.$q.defer();
      if (empty(
      (ref$ = this._cache)[url] || (ref$[url] = []))) {
        this._cache[url] = this.$resource(url).query(function(){
          task.resolve(this$._cache[url]);
        });
      } else {
        task.resolve(this._cache[url]);
      }
      return returnPromise
        ? task.promise
        : this._cache[url];
    };
    return ExternalDataService;
  }());
  if (typeof module != 'undefined' && module !== null) {
    module.exports = ExternalDataService;
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);

},{}],12:[function(require,module,exports){
(function(){
  var NotificationService;
  if (typeof angular != 'undefined' && angular !== null) {
    angular.module("dsc").service("notificationSvc", function($rootScope, $sce){
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t;
        return (t = typeof result)  == "object" || t == "function" ? result || child : child;
  })(NotificationService, arguments, function(){});
    });
  }
  NotificationService = (function(){
    NotificationService.displayName = 'NotificationService';
    var prototype = NotificationService.prototype, constructor = NotificationService;
    function NotificationService($rootScope, $sce){
      var ref$;
      this.$rootScope = $rootScope;
      this.$sce = $sce;
      this.addError = bind$(this, 'addError', prototype);
      this.addInfo = bind$(this, 'addInfo', prototype);
      this.clear = bind$(this, 'clear', prototype);
      this.log = (ref$ = this.$rootScope).notificationLog || (ref$.notificationLog = []);
    }
    prototype.clear = function(){
      this.log.length = 0;
    };
    prototype.addInfo = function(text){
      return this.log.push({
        type: 'info',
        text: this.$sce != null ? this.$sce.trustAsHtml(text) : text
      });
    };
    prototype.addError = function(text){
      return this.log.push({
        type: 'error',
        text: this.$sce != null ? this.$sce.trustAsHtml(text) : text
      });
    };
    return NotificationService;
  }());
  if (typeof module != 'undefined' && module !== null) {
    module.exports = NotificationService;
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);

},{}],13:[function(require,module,exports){
(function(){
  var StorageService;
  if (typeof angular != 'undefined' && angular !== null) {
    angular.module("dsc").config(function(localStorageServiceProvider){
      localStorageServiceProvider.setPrefix("DarkSoulsCompanion");
    }).service("storageSvc", function(localStorageService){
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t;
        return (t = typeof result)  == "object" || t == "function" ? result || child : child;
  })(StorageService, arguments, function(){});
    });
  }
  StorageService = (function(){
    StorageService.displayName = 'StorageService';
    var prototype = StorageService.prototype, constructor = StorageService;
    function StorageService(_localStorageSvc){
      this._localStorageSvc = _localStorageSvc;
      this.read = bind$(this, 'read', prototype);
      this.write = bind$(this, 'write', prototype);
      this.load = bind$(this, 'load', prototype);
      this.save = bind$(this, 'save', prototype);
      this.renameProfile = bind$(this, 'renameProfile', prototype);
      this.profileKeyFrom = bind$(this, 'profileKeyFrom', prototype);
      this.clearProfile = bind$(this, 'clearProfile', prototype);
      this.deleteProfile = bind$(this, 'deleteProfile', prototype);
      this.addProfile = bind$(this, 'addProfile', prototype);
      this.saveProfileList = bind$(this, 'saveProfileList', prototype);
      this.loadProfileList = bind$(this, 'loadProfileList', prototype);
      this.switchToCurrentProfile = bind$(this, 'switchToCurrentProfile', prototype);
      this.switchTo = bind$(this, 'switchTo', prototype);
      this.profileName = '';
      this.profileList = [];
    }
    prototype.switchTo = function(profileName){
      this.profileName = profileName;
      this.write("currentProfileName", this.profileName);
    };
    prototype.switchToCurrentProfile = function(){
      var lastProfile;
      lastProfile = this.read("currentProfileName");
      if (lastProfile != null) {
        this.switchTo(lastProfile);
      } else {
        this.loadProfileList();
        if (this.profileList.length < 1) {
          this.addProfile("Default");
        } else {
          this.switchTo(this.profileList[0]);
        }
      }
    };
    prototype.loadProfileList = function(){
      var ref$;
      this.profileList.length = 0;
      this.profileList = this.profileList.concat((ref$ = this.read("profiles")) != null
        ? ref$
        : []);
      return this.profileList;
    };
    prototype.saveProfileList = function(){
      this.write("profiles", this.profileList);
    };
    prototype.addProfile = function(name, switchTo){
      var existing;
      switchTo == null && (switchTo = true);
      existing = find((function(it){
        return it === name;
      }))(
      this.loadProfileList());
      if (existing == null) {
        this.profileList.push(name);
        this.saveProfileList();
      }
      if (switchTo) {
        this.switchTo(name);
      }
    };
    prototype.deleteProfile = function(name){
      name == null && (name = this.profileName);
      if (this.profileList.length > 1 && find((function(it){
        return it === name;
      }))(
      this.loadProfileList())) {
        this.profileList.splice(this.profileList.indexOf(name), 1);
        this.saveProfileList();
        this.clearProfile(name);
        this.switchTo(this.profileList[0]);
      }
    };
    prototype.clearProfile = function(name){
      var keys, profileKey, i$, len$, key;
      name == null && (name = this.profileName);
      keys = this._localStorageSvc.keys();
      profileKey = this.profileKeyFrom('', name);
      for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
        key = keys[i$];
        if (key.indexOf(profileKey) === 0) {
          this._localStorageSvc.remove(key);
        }
      }
    };
    prototype.profileKeyFrom = function(key, profileName){
      profileName == null && (profileName = this.profileName);
      return "profile:" + profileName + "." + key;
    };
    prototype.renameProfile = function(oldName){
      var this$ = this;
      return {
        to: function(newName){
          var pKey, allKeys, startsWith;
          pKey = this$.profileKeyFrom('', oldName);
          allKeys = this$._localStorageSvc.keys();
          startsWith = this$._localStorageSvc.deriveKey(pKey);
          return console.log(allKeys);
        }
      };
    };
    /**
     * Save data to user's profile
     */
    prototype.save = function(key, data){
      this.write(this.profileKeyFrom(key), data);
    };
    prototype.load = function(key){
      return this.read(this.profileKeyFrom(key));
    };
    prototype.write = function(key, data){
      this._localStorageSvc.set(key, data);
    };
    prototype.read = function(key){
      return this._localStorageSvc.get(key);
    };
    return StorageService;
  }());
  if (typeof module != 'undefined' && module !== null) {
    module.exports = StorageService;
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);

},{}],14:[function(require,module,exports){
(function(){
  angular.module("dsc").controller("armorFinderController", function($q, $scope, storageSvc, itemSvc, armorFinderSvc, statSvc, uiGridConstants){
    var ref$, x$;
    $scope.results = [];
    ({
      maxLoad: 0,
      availableLoad: 0
    });
    $scope.params = (ref$ = storageSvc.load('armor-finder-params')) != null
      ? ref$
      : {
        reservedWeight: 15,
        selectedWeightLimit: 0.50,
        includeUpgrades: true,
        modifiers: [2, 0, 0, 0, 0, 0, 0, 1],
        resultLimit: 10,
        havelRing: false,
        favorRing: false
      };
    $scope.weightLimits = [0.25, 0.50, 0.75, 1.00];
    $scope.modifiers = [
      {
        key: 'phy',
        title: "Physical"
      }, {
        key: 'mag',
        title: "Magic"
      }, {
        key: 'fir',
        title: "Fire"
      }, {
        key: 'lit',
        title: "Lightning"
      }, {
        key: 'blo',
        title: "Bleed"
      }, {
        key: 'tox',
        title: "Poison"
      }, {
        key: 'cur',
        title: "Curse"
      }, {
        key: 'poise',
        title: "Poise"
      }
    ];
    $scope.typeNames = {
      0: 'head',
      1: 'chest',
      2: 'hands',
      3: 'legs'
    };
    $scope.partNames = ['head', 'chest', 'hands', 'legs'];
    x$ = $scope.gridOptions = require('./controller/gridOptions')(uiGridConstants);
    x$.data = $scope.results;
    $scope.calculate = function(type){
      var x$, i$, ref$, len$, index, mod, ref1$;
      type == null && (type = 'offence');
      armorFinderSvc.freeWeight = $scope.availableLoad;
      x$ = armorFinderSvc.params = {};
      x$.freeWeight = $scope.availableLoad;
      x$.includeUpgrades = $scope.params.includeUpgrades;
      x$.resultLimit = $scope.params.resultLimit;
      for (i$ = 0, len$ = (ref$ = $scope.modifiers).length; i$ < len$; ++i$) {
        index = i$;
        mod = ref$[i$];
        ((ref1$ = armorFinderSvc.params).modifiers || (ref1$.modifiers = {}))[mod.key] = $scope.params.modifiers[index];
      }
      armorFinderSvc.findBestCombinations().then(function(results){
        var i$, len$, result;
        $scope.results = [];
        for (i$ = 0, len$ = results.length; i$ < len$; ++i$) {
          result = results[i$];
          $scope.results.push({
            score: result.score,
            weight: result.weight,
            armors: join(', ')(
            map(fn$)(
            result.armors)),
            detailScores: result.detailScores
          });
        }
        $scope.gridOptions.data = $scope.results;
        function fn$(it){
          return it.name;
        }
      });
    };
    $scope.$watch("params", function(){
      var max;
      max = 40 + statSvc.statValueOf('end');
      if ($scope.params.havelRing) {
        max *= 1.5;
      }
      if ($scope.params.favorRing) {
        max *= 1.2;
      }
      $scope.maxLoad = max;
      $scope.availableLoad = max * $scope.params.selectedWeightLimit - $scope.params.reservedWeight;
      storageSvc.save("armor-finder-params", $scope.params);
    }, true);
  });
}).call(this);

},{"./controller/gridOptions":16}],15:[function(require,module,exports){
(function(){
  var ArmorFinderSvc;
  if (typeof angular != 'undefined' && angular !== null) {
    angular.module("dsc").service("armorFinderSvc", function(inventorySvc, itemSvc, $q){
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t;
        return (t = typeof result)  == "object" || t == "function" ? result || child : child;
  })(ArmorFinderSvc, arguments, function(){});
    });
  }
  ArmorFinderSvc = (function(){
    ArmorFinderSvc.displayName = 'ArmorFinderSvc';
    var prototype = ArmorFinderSvc.prototype, constructor = ArmorFinderSvc;
    function ArmorFinderSvc(_inventorySvc, _itemSvc, $q){
      this._inventorySvc = _inventorySvc;
      this._itemSvc = _itemSvc;
      this.$q = $q;
      this.calculateCombinationScores = bind$(this, 'calculateCombinationScores', prototype);
      this.calculateArmorScores = bind$(this, 'calculateArmorScores', prototype);
      this.findAllCombinationsOf = bind$(this, 'findAllCombinationsOf', prototype);
      this.findUsableArmors = bind$(this, 'findUsableArmors', prototype);
      this.takeOnlyAffordable = bind$(this, 'takeOnlyAffordable', prototype);
      this.findCombinationsWithUpgrades = bind$(this, 'findCombinationsWithUpgrades', prototype);
      this.findBestCombinations = bind$(this, 'findBestCombinations', prototype);
      this.freeWeight = 0;
      this.params = {
        resultLimit: 20
      };
      this._debugLog = true;
      this.armorTypes = ['head', 'chest', 'hands', 'legs'];
      this.armorTypeKeys = {
        'head': 0,
        'chest': 1,
        'hands': 2,
        'legs': 3
      };
    }
    prototype.findBestCombinations = function(){
      var start, this$ = this;
      if ((this.params || (this.params = {})).includeUpgrades == null) {
        this.params.includeUpgrades = true;
      }
      start = null;
      return this.findUsableArmors().then(function(armors){
        var combs, end, time;
        this$.calculateArmorScores(armors);
        if (this$.params.includeUpgrades) {
          return this$.findCombinationsWithUpgrades(armors);
        } else {
          start = new Date().getTime();
          combs = this$.findAllCombinationsOf(armors);
          end = new Date().getTime();
          time = end - start;
          if (this$._debugLog) {
            console.log("Permutated " + armors.length + " armors into " + combs.length + " combinations in " + time / 1000 + " seconds");
          }
          start = new Date().getTime();
          combs = this$.calculateCombinationScores(combs);
          end = new Date().getTime();
          time = end - start;
          if (this$._debugLog) {
            console.log("Calculated scores and found the best " + combs.length + " combinations in " + time / 1000 + " seconds");
          }
          return combs;
        }
      }).then(function(combs){
        var i$, len$, comb, j$, ref$, len1$, armor, key, ref1$, val;
        for (i$ = 0, len$ = combs.length; i$ < len$; ++i$) {
          comb = combs[i$];
          comb.detailScores = {};
          for (j$ = 0, len1$ = (ref$ = comb.armors).length; j$ < len1$; ++j$) {
            armor = ref$[j$];
            for (key in ref1$ = armor.detailScores) {
              val = ref1$[key];
              if (comb.detailScores[key] == null) {
                comb.detailScores[key] = 0;
              }
              comb.detailScores[key] += val;
            }
          }
        }
        return combs;
      });
    };
    prototype.findCombinationsWithUpgrades = function(armors){
      var start, staticArmors, dynamicArmors, combinations, end, time, best, i$, len$, comb, j$, ref$, len1$, armor, upgradedArmors, promises, this$ = this;
      start = new Date().getTime();
      staticArmors = armors;
      dynamicArmors = reject(function(it){
        return it.matSetId < 0;
      })(
      armors);
      combinations = this.findAllCombinationsOf(dynamicArmors);
      end = new Date().getTime();
      time = end - start;
      console.log("Permutated " + dynamicArmors.length + " upgradeable armors into " + combinations.length + " combinations in " + time / 1000 + " seconds");
      start = new Date().getTime();
      best = this.calculateCombinationScores(combinations, 40);
      end = new Date().getTime();
      time = end - start;
      if (this._debugLog) {
        console.log("Scored and found the " + best.length + " best combinations in " + time / 1000 + " seconds");
      }
      dynamicArmors.length = 0;
      for (i$ = 0, len$ = best.length; i$ < len$; ++i$) {
        comb = best[i$];
        for (j$ = 0, len1$ = (ref$ = comb.armors).length; j$ < len1$; ++j$) {
          armor = ref$[j$];
          dynamicArmors.push(armor);
        }
      }
      dynamicArmors = unique(
      dynamicArmors);
      upgradedArmors = [];
      promises = [];
      for (i$ = 0, len$ = dynamicArmors.length; i$ < len$; ++i$) {
        armor = dynamicArmors[i$];
        promises.push(this._inventorySvc.findAllAvailableUpgradesFor(armor).then(fn$));
      }
      return this.$q.all(promises).then(function(upgradedArmors){
        var dynamicArmors, combs, end, time;
        dynamicArmors = upgradedArmors;
        upgradedArmors = null;
        start = new Date().getTime();
        combs = this$.findAllCombinationsOf(dynamicArmors);
        end = new Date().getTime();
        time = end - start;
        if (this$._debugLog) {
          console.log("Permutated " + dynamicArmors.length + " armors & upgrades into " + combs.length + " combinations in " + time / 1000 + " seconds");
        }
        start = new Date().getTime();
        return this$.takeOnlyAffordable(combs);
      }).then(function(combs){
        var end, time, dynamicArmors, i$, len$, comb, j$, ref$, len1$, armor;
        end = new Date().getTime();
        time = end - start;
        if (this$._debugLog) {
          console.log("Kept " + combs.length + " affordable combinations in " + time / 1000 + " seconds");
        }
        start = new Date().getTime();
        dynamicArmors = [];
        for (i$ = 0, len$ = combs.length; i$ < len$; ++i$) {
          comb = combs[i$];
          for (j$ = 0, len1$ = (ref$ = comb.armors).length; j$ < len1$; ++j$) {
            armor = ref$[j$];
            dynamicArmors.push(armor);
          }
        }
        dynamicArmors = unique(
        dynamicArmors.concat(staticArmors));
        end = new Date().getTime();
        time = end - start;
        if (this$._debugLog) {
          console.log("Extracted and merged " + dynamicArmors.length + " armors, upgrades and un-upgradable armors in " + time / 1000 + " seconds");
        }
        start = new Date().getTime();
        combs = this$.findAllCombinationsOf(dynamicArmors);
        end = new Date().getTime();
        time = end - start;
        if (this$._debugLog) {
          console.log("Permutated " + dynamicArmors.length + " armors, upgrades and un-upgradable armors into " + combs.length + " combinations in " + time / 1000 + " seconds");
        }
        dynamicArmors = null;
        start = new Date().getTime();
        return this$.takeOnlyAffordable(combs);
      }).then(function(combs){
        var end, time, i$, len$, comb;
        end = new Date().getTime();
        time = end - start;
        if (this$._debugLog) {
          console.log("Found and kept " + combs.length + " affordable combinations in " + time / 1000 + " seconds");
        }
        start = new Date().getTime();
        for (i$ = 0, len$ = combs.length; i$ < len$; ++i$) {
          comb = combs[i$];
          comb.armors = this$.calculateArmorScores(comb.armors);
        }
        end = new Date().getTime();
        time = end - start;
        if (this$._debugLog) {
          console.log("Calculated armor scores for " + combs.length + " combinations in " + time / 1000 + " seconds");
        }
        start = new Date().getTime();
        combs = this$.calculateCombinationScores(combs);
        end = new Date().getTime();
        time = end - start;
        if (this$._debugLog) {
          console.log("Calculated scores and found the best " + combs.length + " combinations in " + time / 1000 + " seconds");
        }
        return combs;
      });
      function fn$(upgrades){
        var i$, len$, upgrade;
        for (i$ = 0, len$ = upgrades.length; i$ < len$; ++i$) {
          upgrade = upgrades[i$];
          delete upgrade.score;
        }
        return upgradedArmors = upgradedArmors.concat(upgrades);
      }
    };
    /**
     * Given a list of combinations, only take those that the user can afford.
     */
    prototype.takeOnlyAffordable = function(combinations){
      var canAfford, this$ = this;
      canAfford = [];
      return this._inventorySvc.load().then(function(inventory){
        var i$, ref$, len$, comb, unUpgraded, j$, ref1$, len1$, armor, k$, ref2$, len2$, aCost, cCost, l$, ref3$, len3$, x, can, materials, item, cost, material, mat;
        for (i$ = 0, len$ = (ref$ = combinations).length; i$ < len$; ++i$) {
          comb = ref$[i$];
          comb.totalCost = [];
          unUpgraded = 0;
          for (j$ = 0, len1$ = (ref1$ = comb.armors).length; j$ < len1$; ++j$) {
            armor = ref1$[j$];
            if (armor.totalCost == null) {
              unUpgraded++;
              continue;
            }
            for (k$ = 0, len2$ = (ref2$ = armor.totalCost).length; k$ < len2$; ++k$) {
              aCost = ref2$[k$];
              cCost = null;
              for (l$ = 0, len3$ = (ref3$ = comb.totalCost).length; l$ < len3$; ++l$) {
                x = ref3$[l$];
                if (x.matId === aCost.matId) {
                  cCost = x;
                  break;
                }
              }
              if (cCost == null) {
                cCost = {
                  matId: aCost.matId,
                  matCost: 0
                };
                comb.totalCost.push(cCost);
              }
              cCost.matCost += aCost.matCost;
            }
          }
          can = true;
          if (unUpgraded < 4) {
            materials = [];
            for (j$ = 0, len1$ = inventory.length; j$ < len1$; ++j$) {
              item = inventory[j$];
              if (item.itemType === 'item') {
                materials.push(item);
              }
            }
            for (j$ = 0, len1$ = (ref1$ = comb.totalCost).length; j$ < len1$; ++j$) {
              cost = ref1$[j$];
              material = null;
              for (k$ = 0, len2$ = materials.length; k$ < len2$; ++k$) {
                mat = materials[k$];
                if (mat.id === cost.matId) {
                  material = mat;
                  break;
                }
              }
              if (!(material != null && material.amount >= cost.matCost)) {
                can = false;
              }
            }
          }
          if (can) {
            canAfford.push(comb);
          }
        }
        return canAfford;
      });
    };
    /**
     * Find armors fit for using in calculations.
     */
    prototype.findUsableArmors = function(){
      var this$ = this;
      return this._inventorySvc.load().then(function(inventory){
        var promises, i$, len$, entry;
        promises = [];
        for (i$ = 0, len$ = inventory.length; i$ < len$; ++i$) {
          entry = inventory[i$];
          if (entry.itemType == null) {
            console.log(entry);
            throw new Error("Above inventory entry does not have an [.itemType] set:");
          }
          if (entry.itemType !== 'armor') {
            continue;
          }
          promises.push(this$._itemSvc.findAnyItemByUid(entry.uid));
        }
        return this$.$q.all(promises);
      }).then(function(armors){
        return filter(function(it){
          return it.weight <= this$.freeWeight;
        })(
        armors);
      });
    };
    /**
     * Take a list of armors and generate every possible combination of them
     * within the current weight limit.
     * @returns Promise that will be resolved with an array of combinations.
     */
    prototype.findAllCombinationsOf = function(armors){
      var combinations, empties, i$, ref$, len$, index, type, empty, groupOf, lengths, pieces, a, b, c, d, weight, upgradeLevel;
      combinations = [];
      empties = [];
      for (i$ = 0, len$ = (ref$ = this.armorTypes).length; i$ < len$; ++i$) {
        index = i$;
        type = ref$[i$];
        empty = find(fn$)(
        armors);
        if (empty == null) {
          empty = {
            name: "(bare " + type + ")",
            itemType: 'armor',
            armorType: type,
            weight: 0,
            upgradeId: -1,
            id: -(index + 1),
            score: 0
          };
          armors.push(empty);
        }
        empties.push(empty);
      }
      groupOf = groupBy(function(it){
        return it.armorType;
      })(
      armors);
      lengths = map(function(it){
        return (it != null ? it.length : void 8) || 0;
      })(
      [groupOf['head'], groupOf['chest'], groupOf['hands'], groupOf['legs']]);
      if (this._debugLog) {
        console.log("Lengths:", lengths);
      }
      pieces = [null, null, null, null];
      a = lengths[0] - 1;
      do {
        pieces[0] = groupOf['head'][a];
        pieces[1] = pieces[2] = pieces[3] = null;
        b = lengths[1] - 1;
        do {
          pieces[1] = groupOf['chest'][b];
          pieces[2] = pieces[3] = null;
          c = lengths[2] - 1;
          do {
            pieces[2] = groupOf['hands'][c];
            pieces[3] = null;
            d = lengths[3] - 1;
            do {
              pieces[3] = groupOf['legs'][d];
              weight = pieces[0].weight + pieces[1].weight + pieces[2].weight + pieces[3].weight;
              upgradeLevel = pieces[0].upgradeLevel + pieces[1].upgradeLevel + pieces[2].upgradeLevel + pieces[3].upgradeLevel;
              if (weight <= this.freeWeight) {
                combinations.push({
                  armors: [].concat(pieces),
                  weight: weight,
                  upgradeLevel: upgradeLevel
                });
              }
            } while (--d >= 0);
          } while (--c >= 0);
        } while (--b >= 0);
      } while (--a >= 0);
      return combinations;
      function fn$(it){
        return it.armorType === type && it.id < 0;
      }
    };
    prototype.calculateArmorScores = function(armors){
      var modSet, i$, len$, armor, j$, len1$, mod, ref$, ref1$;
      modSet = [['phy', 'defPhy'], ['mag', 'defMag'], ['fir', 'defFir'], ['lit', 'defLit'], ['blo', 'defBlo'], ['tox', 'defTox'], ['cur', 'defCur'], ['poise', 'defPoise']];
      for (i$ = 0, len$ = armors.length; i$ < len$; ++i$) {
        armor = armors[i$];
        if (armor.score != null) {
          continue;
        }
        armor.score = 0;
        armor.detailScores = {};
        for (j$ = 0, len1$ = modSet.length; j$ < len1$; ++j$) {
          mod = modSet[j$];
          armor.detailScores[mod[0]] = (ref$ = armor[mod[1]]) != null ? ref$ : 0;
          armor.score += ((ref$ = armor[mod[1]]) != null ? ref$ : 0) * ((ref$ = ((ref1$ = this.params).modifiers || (ref1$.modifiers = {}))[mod[0]]) != null ? ref$ : 0);
        }
      }
      return armors;
    };
    prototype.calculateCombinationScores = function(combinations, limit){
      var best, i$, a, comb, to$, j$;
      limit == null && (limit = this.params.resultLimit);
      best = [];
      for (i$ = 0; i$ < limit; ++i$) {
        a = i$;
        if ((comb = combinations.pop()) == null) {
          continue;
        }
        comb.score = comb.armors[0].score + comb.armors[1].score + comb.armors[2].score + comb.armors[3].score;
        best.push(comb);
      }
      for (i$ = 0, to$ = combinations.length; i$ < to$; ++i$) {
        a = i$;
        comb = combinations.pop();
        comb.score = comb.armors[0].score + comb.armors[1].score + comb.armors[2].score + comb.armors[3].score;
        for (j$ = 0; j$ < limit; ++j$) {
          a = j$;
          if (comb.score > best[a].score) {
            best[a] = comb;
            break;
          }
        }
      }
      return best;
    };
    return ArmorFinderSvc;
  }());
  if (typeof module != 'undefined' && module !== null) {
    module.exports = ArmorFinderSvc;
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);

},{}],16:[function(require,module,exports){
(function(){
  if (typeof module != 'undefined' && module !== null) {
    module.exports = function(uiGridConstants){
      var percentFieldMinWidth;
      percentFieldMinWidth = 45;
      return {
        columnDefs: [
          {
            field: 'score',
            width: 75,
            cellFilter: 'number:2',
            sort: {
              direction: uiGridConstants.DESC,
              priority: 0
            },
            type: 'number'
          }, {
            field: 'weight',
            width: 50,
            cellFilter: 'number:2',
            type: 'number',
            sort: {
              direction: uiGridConstants.ASC,
              priority: 1
            }
          }, {
            field: 'armors',
            minWidth: 700
          }, {
            field: 'detailScores.phy',
            minWidth: 50,
            cellFilter: 'number:0',
            type: 'number',
            displayName: 'Phys.'
          }, {
            field: 'detailScores.mag',
            minWidth: 50,
            cellFilter: 'number:0',
            type: 'number',
            displayName: 'Magic'
          }, {
            field: 'detailScores.fir',
            minWidth: 50,
            cellFilter: 'number:0',
            type: 'number',
            displayName: 'Fire'
          }, {
            field: 'detailScores.lit',
            minWidth: 50,
            cellFilter: 'number:0',
            type: 'number',
            displayName: 'Light.'
          }, {
            field: 'detailScores.blo',
            minWidth: 50,
            cellFilter: 'number:0',
            type: 'number',
            displayName: 'Bleed'
          }, {
            field: 'detailScores.tox',
            minWidth: 50,
            cellFilter: 'number:0',
            type: 'number',
            displayName: 'Tox.'
          }, {
            field: 'detailScores.cur',
            minWidth: 50,
            cellFilter: 'number:0',
            type: 'number',
            displayName: 'Curse'
          }, {
            field: 'detailScores.poise',
            minWidth: 50,
            cellFilter: 'number:0',
            type: 'number',
            displayName: 'Poise'
          }
        ]
      };
    };
  }
}).call(this);

},{}],17:[function(require,module,exports){
(function(){
  angular.module("dsc");
  require('./armor-finder-service');
  require('./armor-finder-controller');
}).call(this);

},{"./armor-finder-controller":14,"./armor-finder-service":15}],18:[function(require,module,exports){
(function(){
  var GuideController;
  if (typeof angular != 'undefined' && angular !== null) {
    angular.module("dsc").controller("GuideController", function($sce, $scope, $routeParams, $resource, guideSvc, storageSvc){
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t;
        return (t = typeof result)  == "object" || t == "function" ? result || child : child;
  })(GuideController, arguments, function(){});
    });
  }
  GuideController = (function(){
    GuideController.displayName = 'GuideController';
    var prototype = GuideController.prototype, constructor = GuideController;
    function GuideController($sce, $scope, $routeParams, $resource, _guideSvc, _storageSvc){
      this.$sce = $sce;
      this.$scope = $scope;
      this.$routeParams = $routeParams;
      this.$resource = $resource;
      this._guideSvc = _guideSvc;
      this._storageSvc = _storageSvc;
      this.processReqs = bind$(this, 'processReqs', prototype);
      this.loadUserData = bind$(this, 'loadUserData', prototype);
      this.saveUserData = bind$(this, 'saveUserData', prototype);
      this.prepareGuideContent = bind$(this, 'prepareGuideContent', prototype);
      this.getArrowFor = bind$(this, 'getArrowFor', prototype);
      this.enact = bind$(this, 'enact', prototype);
      this.entryClicked = bind$(this, 'entryClicked', prototype);
      this.canAddToInventory = bind$(this, 'canAddToInventory', prototype);
      this.wireUp = bind$(this, 'wireUp', prototype);
      this.load = bind$(this, 'load', prototype);
      this.setup = bind$(this, 'setup', prototype);
      this.setup();
      this.load();
      this.wireUp();
    }
    prototype.setup = function(){
      this.$scope.sections = [
        {
          id: 'intro',
          name: "Intro"
        }, {
          id: 'asylum',
          name: "Northern Undead Asylum"
        }, {
          id: 'firelink',
          name: "Firelink Shrine"
        }, {
          id: 'burg',
          name: "Undead Burg"
        }, {
          id: 'parish',
          name: "Undead Parish"
        }, {
          id: 'low',
          name: "Lower Undead Burg"
        }, {
          id: 'depths',
          name: "The Depths"
        }, {
          id: 'blight',
          name: "Blighttown"
        }, {
          id: 'quelaag',
          name: "Quelaag's Domain"
        }
      ];
      this.$scope.section = this.$routeParams['section'];
      this.$scope.userData = null;
      this.$scope.entryIndex = {};
    };
    prototype.load = function(){
      var data, this$ = this;
      this.loadUserData();
      data = this._guideSvc.getContentFor(this.$scope.section);
      this.$scope.entry = {
        children: data
      };
      data.$promise.then(function(){
        this$.prepareGuideContent(this$.$scope.entry);
        this$.processReqs();
      });
    };
    prototype.wireUp = function(){
      var i$, ref$, len$, func;
      for (i$ = 0, len$ = (ref$ = ['canAddToInventory', 'markDone', 'entryClicked', 'enact']).length; i$ < len$; ++i$) {
        func = ref$[i$];
        this.$scope[func] = this[func];
      }
    };
    prototype.canAddToInventory = function(entry){
      var can;
      can = any((function(it){
        return it === 'item';
      }))(
      entry.labels || (entry.labels = []));
      return can;
    };
    prototype.entryClicked = function($event, entry){
      var x$;
      $event.stopPropagation();
      if (!(entry.meta || (entry.meta = {})).isExpandable) {
        return;
      }
      x$ = entry.meta || (entry.meta = {});
      x$.isCollapsed = !(entry.meta || (entry.meta = {})).isCollapsed;
      x$.arrow = this.getArrowFor(entry);
      this.saveUserData();
    };
    prototype.entryDone = function(entry){
      entry.meta.isDone = true;
      this.saveUserData();
    };
    prototype.enact = function(entry){
      var i$, ref$, len$, type, j$, ref1$, len1$, flag, ref2$;
      for (i$ = 0, len$ = (ref$ = ['setFlags', 'clearFlags']).length; i$ < len$; ++i$) {
        type = ref$[i$];
        if (entry[type] == null) {
          continue;
        }
        if (entry[type].constructor !== Array) {
          entry[type] = [entry[type]];
        }
        for (j$ = 0, len1$ = (ref1$ = entry[type]).length; j$ < len1$; ++j$) {
          flag = ref1$[j$];
          ((ref2$ = this.$scope.userData).flags || (ref2$.flags = {}))[flag] = type === 'setFlags';
        }
      }
      this.processReqs();
    };
    prototype.getArrowFor = function(entry){
      if (!(entry.meta || (entry.meta = {})).isExpandable) {
        return '';
      }
      return (entry.meta || (entry.meta = {})).isCollapsed ? '[..]' : '';
    };
    prototype.prepareGuideContent = function(entry){
      var userMeta, ref$, ref1$, ref2$, x$, i$, len$, check, child;
      if (entry.id != null) {
        this.$scope.entryIndex[entry.id] = entry;
      }
      if (entry.content != null) {
        entry.content = this.$sce.trustAsHtml(entry.content);
      }
      userMeta = (ref$ = ((ref1$ = (ref2$ = this.$scope).userData || (ref2$.userData = {})).entryMeta || (ref1$.entryMeta = {}))[entry.id]) != null
        ? ref$
        : {};
      if (typeof (entry.labels || (entry.labels = [])) === 'string') {
        entry.labels = [entry.labels];
      }
      x$ = entry.meta || (entry.meta = {});
      x$.isCollapsed = (ref$ = userMeta.isCollapsed) != null
        ? ref$
        : entry.content != null;
      x$.isDone = (ref$ = userMeta.isDone) != null ? ref$ : false;
      x$.isExpandable = entry.children != null || entry.content != null;
      x$.arrow = this.getArrowFor(entry);
      x$.setsFlags = entry.setFlags != null || entry.clearFlags != null;
      x$.isItem = in$('item', entry.labels);
      for (i$ = 0, len$ = (ref$ = ['content', 'children']).length; i$ < len$; ++i$) {
        check = ref$[i$];
        ((ref1$ = entry.meta || (entry.meta = {})).additionalClasses || (ref1$.additionalClasses = [])).push(entry[check] != null
          ? "with-" + check
          : "without-" + check);
      }
      if (entry.children != null) {
        for (i$ = 0, len$ = (ref$ = entry.children).length; i$ < len$; ++i$) {
          child = ref$[i$];
          this.prepareGuideContent(child);
        }
      }
    };
    prototype.saveUserData = function(){
      var id, ref$, entry, i$, ref1$, len$, field, ref2$, ref3$, ref4$;
      for (id in ref$ = this.$scope.entryIndex) {
        entry = ref$[id];
        for (i$ = 0, len$ = (ref1$ = ['isCollapsed', 'isDone']).length; i$ < len$; ++i$) {
          field = ref1$[i$];
          ((ref2$ = (ref3$ = (ref4$ = this.$scope).userData || (ref4$.userData = {})).entryMeta || (ref3$.entryMeta = {}))[id] || (ref2$[id] = {}))[field] = entry.meta[field];
        }
      }
      this._storageSvc.save('guide:userData', this.$scope.userData);
    };
    prototype.loadUserData = function(){
      var ref$;
      this.$scope.userData = (ref$ = this._storageSvc.load('guide:userData')) != null
        ? ref$
        : {};
    };
    /**
     *
     */
    prototype.processReqs = function(){
      var id, ref$, entry, i$, ref1$, len$, key, j$, ref2$, len1$, req, ref3$;
      for (id in ref$ = this.$scope.entryIndex) {
        entry = ref$[id];
        entry.meta.isEnabled = true;
        for (i$ = 0, len$ = (ref1$ = ['req', 'reqNot']).length; i$ < len$; ++i$) {
          key = ref1$[i$];
          if (entry[key] == null) {
            continue;
          }
          if (entry[key].constructor !== Array) {
            entry[key] = [entry[key]];
          }
          for (j$ = 0, len1$ = (ref2$ = entry[key]).length; j$ < len1$; ++j$) {
            req = ref2$[j$];
            if (typeof req === 'string') {
              entry.meta.isEnabled = (key === 'req') === (((ref3$ = this.$scope.userData).flags || (ref3$.flags = {}))[req] === true);
            }
            if (!entry.meta.isEnabled) {
              break;
            }
          }
          if (!entry.meta.isEnabled) {
            break;
          }
        }
      }
    };
    return GuideController;
  }());
  if (typeof module != 'undefined' && module !== null) {
    module.exports = GuideController;
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);

},{}],19:[function(require,module,exports){
(function(){
  angular.module("dsc").service("guideSvc", function($resource){
    var svc;
    svc = {};
    svc.getContentFor = function(section){
      return $resource("/modules/guide/content/" + section + ".json").query();
    };
    return svc;
  });
}).call(this);

},{}],20:[function(require,module,exports){
(function(){
  require('./guide-controller');
  require('./guide-service');
}).call(this);

},{"./guide-controller":18,"./guide-service":19}],21:[function(require,module,exports){
(function(){
  var ItemServiceUpgradeComponent;
  ItemServiceUpgradeComponent = (function(){
    ItemServiceUpgradeComponent.displayName = 'ItemServiceUpgradeComponent';
    var prototype = ItemServiceUpgradeComponent.prototype, constructor = ItemServiceUpgradeComponent;
    function ItemServiceUpgradeComponent(_itemSvc, _externalDataSvc, _itemIndexSvc, $q){
      this._itemSvc = _itemSvc;
      this._externalDataSvc = _externalDataSvc;
      this._itemIndexSvc = _itemIndexSvc;
      this.$q = $q;
      this.apply = bind$(this, 'apply', prototype);
      this.canBeUpgradedFurther = bind$(this, 'canBeUpgradedFurther', prototype);
      this.canBeUpgraded = bind$(this, 'canBeUpgraded', prototype);
      this.isUpgraded = bind$(this, 'isUpgraded', prototype);
      this.upgradeLevelOf = bind$(this, 'upgradeLevelOf', prototype);
      this.ensureItCanBeUpgraded = bind$(this, 'ensureItCanBeUpgraded', prototype);
      this.loadAllUpgrades = bind$(this, 'loadAllUpgrades', prototype);
      this.loadAllMaterialSets = bind$(this, 'loadAllMaterialSets', prototype);
      this.findUpgradeMaterialsFor = bind$(this, 'findUpgradeMaterialsFor', prototype);
      this.findUpgradeFor = bind$(this, 'findUpgradeFor', prototype);
      this.findBaseItem = bind$(this, 'findBaseItem', prototype);
      this.getBaseItemIdOf = bind$(this, 'getBaseItemIdOf', prototype);
      this.getUpgradeLevelFrom = bind$(this, 'getUpgradeLevelFrom', prototype);
      this.getBaseIdFrom = bind$(this, 'getBaseIdFrom', prototype);
      this.clearMaterialSets = bind$(this, 'clearMaterialSets', prototype);
      this.clearUpgrades = bind$(this, 'clearUpgrades', prototype);
      this._upgrades = {};
      this._materialSets = [];
    }
    prototype.clearUpgrades = function(){
      var i$, ref$, len$, type, ref1$;
      for (i$ = 0, len$ = (ref$ = ['weapon', 'armor']).length; i$ < len$; ++i$) {
        type = ref$[i$];
        ((ref1$ = this._upgrades)[type] || (ref1$[type] = [])).length = 0;
        delete this._upgrades[type].$promise;
      }
      return this;
    };
    prototype.clearMaterialSets = function(){
      this._materialSets.length = 0;
      delete this._materialSets.$promise;
      return this;
    };
    prototype.getBaseIdFrom = function(id){
      return id - this.getUpgradeLevelFrom(id);
    };
    prototype.getUpgradeLevelFrom = function(id){
      return id % 100;
    };
    prototype.getBaseItemIdOf = function(item){
      return this.getBaseIdFrom(item.id);
    };
    prototype.findBaseItem = function(item){
      var this$ = this;
      return this._itemSvc.findItem(item.itemType, function(it){
        return it.id === this$.getBaseIdFrom(item.id);
      });
    };
    /**
     * Get the upgrade model for a given weapon at a given upgrade level
     * @returns Promise, resolved with the upgrade (or null if nothing found)
     */
    prototype.findUpgradeFor = function(item, level){
      var this$ = this;
      return this.loadAllUpgrades(item.itemType).then(function(upgrades){
        if (item.matSetId < 0) {
          return null;
        }
        return find(function(it){
          return it.id === this$.getBaseIdFrom(item.upgradeId) + level;
        })(
        upgrades);
      });
    };
    /**
     * Find the materials required to upgrade a given item using a given upgrade model.
     * @returns Promise that is resolved with the material data.
     */
    prototype.findUpgradeMaterialsFor = function(item, upgrade){
      var x$, this$ = this;
      if (!(item != null && upgrade != null)) {
        throw new Error("Can't find upgrade materials, either item or upgrade is unset.");
      }
      if (item.matSetId < 0) {
        x$ = this.$q.defer();
        x$.resolve(null);
        return x$.promise;
      }
      return this.loadAllMaterialSets().then(function(){
        return find(function(it){
          return it.id === this$.getBaseIdFrom(item.matSetId) + upgrade.matSetId;
        })(
        this$._materialSets);
      });
    };
    /**
     * Asynchronously loads all information on material sets required for upgrades
     * @returns Promise that will be resolved with the material set data.
     */
    prototype.loadAllMaterialSets = function(){
      if (this._materialSets.$promise == null) {
        this._materialSets = this._externalDataSvc.loadJson("/modules/items/content/material-sets.json", false);
      }
      return this._materialSets.$promise;
    };
    /**
     * Load information on all upgrades for a given item type
     * @returns Promise resolved with the upgrade data
     */
    prototype.loadAllUpgrades = function(itemType){
      var ref$;
      this.ensureItCanBeUpgraded(
      itemType);
      if (((ref$ = this._upgrades)[itemType] || (ref$[itemType] = [])).$promise == null) {
        this._upgrades[itemType] = this._externalDataSvc.loadJson("/modules/items/content/" + itemType + "-upgrades.json", false);
      }
      return this._upgrades[itemType].$promise;
    };
    prototype.ensureItCanBeUpgraded = function(item){
      if (item == null) {
        throw new Error("Item / item type not provided.");
      }
      if (typeof item === 'string') {
        item = {
          itemType: item
        };
      }
      if (!this.canBeUpgraded(
      item)) {
        throw new Error("Only weapons and armors can be upgraded, this is a [" + item.itemType + "].");
      }
    };
    prototype.upgradeLevelOf = function(item){
      return item.id % 100;
    };
    prototype.isUpgraded = function(item){
      return this.upgradeLevelOf(item) > 0;
    };
    prototype.canBeUpgraded = function(item){
      return item.itemType === 'weapon' || item.itemType === 'armor';
    };
    prototype.canBeUpgradedFurther = function(item){
      var this$ = this;
      if (!this.canBeUpgraded(item) || item.weaponType === 'Magic' || item.matSetId < 0 || item.upgradeId < 0) {
        return false;
      }
      return this.findUpgradeFor(item, this.upgradeLevelOf(item) + 1).then(function(upgrade){
        if (this$._debugLog && upgrade == null) {
          console.log("Failed to find an upgrade for item (id: " + item.id + ") at level " + this$.upgradeLevelOf(item));
        }
        return upgrade != null;
      });
    };
    prototype.apply = function(upgrade){
      var this$ = this;
      if (upgrade == null) {
        throw new Error("No upgrade data provided.");
      }
      return {
        to: function(item){
          var x$, i$, ref$, len$, field, ref1$;
          this$.ensureItCanBeUpgraded(
          item);
          x$ = item;
          x$.id += upgrade['id'] % 100;
          x$.upgradeId = upgrade['id'];
          x$.matSetId += upgrade['matSetId'];
          for (i$ = 0, len$ = (ref$ = [['defPhy', 'defModPhy'], ['defMag', 'defModMag'], ['defFir', 'defModFir'], ['defLit', 'defModLit'], ['defTox', 'defModTox'], ['defBlo', 'defModBlo'], ['defCur', 'defModCur']]).length; i$ < len$; ++i$) {
            field = ref$[i$];
            item[field[0]] *= (ref1$ = upgrade[field[1]]) != null ? ref1$ : 1;
          }
          switch (item['itemType']) {
          case 'weapon':
            for (i$ = 0, len$ = (ref$ = [['atkPhy', 'atkModPhy'], ['atkMag', 'atkModMag'], ['atkFir', 'atkModFir'], ['atkLit', 'atkModLit'], ['bonusStr', 'bonusModStr'], ['bonusDex', 'bonusModDex'], ['bonusInt', 'bonusModInt'], ['bonusFai', 'bonusModFai'], ['defSta', 'defModSta']]).length; i$ < len$; ++i$) {
              field = ref$[i$];
              item[field[0]] *= (ref1$ = upgrade[field[1]]) != null ? ref1$ : 1;
            }
            break;
          case 'armor':
            for (i$ = 0, len$ = (ref$ = [['defStrike', 'defModStrike'], ['defSlash', 'defModSlash'], ['defThrust', 'defModThrust']]).length; i$ < len$; ++i$) {
              field = ref$[i$];
              item[field[0]] *= (ref1$ = upgrade[field[1]]) != null ? ref1$ : 1;
            }
          }
          return item;
        }
      };
    };
    return ItemServiceUpgradeComponent;
  }());
  if (typeof module != 'undefined' && module !== null) {
    module.exports = ItemServiceUpgradeComponent;
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);

},{}],22:[function(require,module,exports){
(function(){
  if (typeof module != 'undefined' && module !== null) {
    module.exports = function($scope, uiGridConstants){
      var percentFieldMinWidth, i$, ref$, len$, itemType;
      $scope.gridOptions = {
        enableFiltering: true
      };
      percentFieldMinWidth = 45;
      $scope.columnConfigs = {
        'weapon': [
          {
            field: 'weaponType',
            displayName: 'Type',
            minWidth: 70,
            sort: {
              direction: uiGridConstants.ASC,
              priority: 0
            }
          }, {
            field: 'name',
            minWidth: 210,
            sort: {
              direction: uiGridConstants.ASC,
              priority: 1
            }
          }, {
            field: 'reqStr',
            displayName: 'RS',
            type: 'number'
          }, {
            field: 'reqDex',
            displayName: 'RD'
          }, {
            field: 'reqInt',
            displayName: 'RI'
          }, {
            field: 'reqFai',
            displayName: 'RF'
          }, {
            field: 'atkPhy',
            displayName: 'AP'
          }, {
            field: 'atkMag',
            displayName: 'AM'
          }, {
            field: 'atkFir',
            displayName: 'AF'
          }, {
            field: 'atkLit',
            displayName: 'AL'
          }, {
            field: 'bonusStr',
            displayName: 'SS',
            minWidth: percentFieldMinWidth,
            cellFilter: 'percentage'
          }, {
            field: 'bonusDex',
            displayName: 'SD',
            minWidth: percentFieldMinWidth,
            cellFilter: 'percentage'
          }, {
            field: 'bonusInt',
            displayName: 'SI',
            minWidth: percentFieldMinWidth,
            cellFilter: 'percentage'
          }, {
            field: 'bonusFai',
            displayName: 'SF',
            minWidth: percentFieldMinWidth,
            cellFilter: 'percentage'
          }, {
            field: 'defPhy',
            displayName: 'DP'
          }, {
            field: 'defMag',
            displayName: 'DM'
          }, {
            field: 'defFir',
            displayName: 'DF'
          }, {
            field: 'defLit',
            displayName: 'DL'
          }, {
            field: 'defTox',
            displayName: 'DT'
          }, {
            field: 'defBlo',
            displayName: 'DB'
          }, {
            field: 'defCur',
            displayName: 'DC'
          }, {
            field: 'defSta',
            displayName: 'St'
          }, {
            field: 'divine',
            minWidth: percentFieldMinWidth,
            displayName: 'Div',
            cellFilter: 'percentage'
          }, {
            field: 'occult',
            minWidth: percentFieldMinWidth,
            displayName: 'Occ',
            cellFilter: 'percentage'
          }, {
            field: 'weight',
            displayName: 'Wt',
            cellFilter: "number:2",
            type: 'number'
          }, {
            field: 'atkStaCost',
            displayNamo: 'Sta',
            cellFilter: "number:2",
            type: 'number'
          }, {
            field: 'dpsPhy',
            displayNamo: 'dpsP',
            cellFilter: "number:2",
            type: 'number'
          }, {
            field: 'dpsMag',
            displayNamo: 'dpsM',
            cellFilter: "number:2",
            type: 'number'
          }, {
            field: 'dpsFir',
            displayNamo: 'dpsF',
            cellFilter: "number:2",
            type: 'number'
          }, {
            field: 'dpsLit',
            displayNamo: 'dpsL',
            cellFilter: "number:2",
            type: 'number'
          }
        ],
        'armor': [
          {
            name: 'armorSet',
            displayName: 'Set',
            minWidth: 150,
            sort: {
              direction: uiGridConstants.ASC,
              priority: 0
            }
          }, {
            name: 'armorType',
            displayName: 'Type',
            sort: {
              direction: uiGridConstants.ASC,
              priority: 1
            },
            sortingAlgorithm: function(a, b){
              var values;
              values = {
                'head': 1,
                'chest': 2,
                'hands': 3,
                'legs': 4
              };
              return values[a] > values[b]
                ? 1
                : values[a] < values[b] ? -1 : 0;
            }
          }, {
            field: 'name',
            minWidth: 250
          }, {
            name: 'defPhy',
            type: 'number',
            displayName: 'DN'
          }, {
            name: 'defMag',
            type: 'number',
            displayName: 'DM'
          }, {
            name: 'defFir',
            type: 'number',
            displayName: 'DF'
          }, {
            name: 'defLit',
            type: 'number',
            displayName: 'DL'
          }, {
            name: 'defPoise',
            type: 'number',
            displayName: 'DP'
          }, {
            name: 'defTox',
            type: 'number',
            displayName: 'RP'
          }, {
            name: 'defBlo',
            type: 'number',
            displayName: 'RB'
          }, {
            name: 'defCur',
            type: 'number',
            displayName: 'RC'
          }, {
            name: 'stRec',
            type: 'number',
            displayName: 'Sr'
          }, {
            name: 'weight',
            type: 'number',
            displayName: 'Wt'
          }
        ]
      };
      for (i$ = 0, len$ = (ref$ = ['item', 'rings']).length; i$ < len$; ++i$) {
        itemType = ref$[i$];
        $scope.columnConfigs[itemType] = [{
          field: 'name',
          sort: {
            direction: uiGridConstants.ASC,
            priority: 0
          }
        }];
      }
    };
  }
}).call(this);

},{}],23:[function(require,module,exports){
(function(){
  var ItemIndexService;
  if (typeof angular != 'undefined' && angular !== null) {
    angular.module("dsc").service("itemIndexSvc", function(externalDataSvc){
      return new ItemIndexService(externalDataSvc);
    });
  }
  ItemIndexService = (function(){
    ItemIndexService.displayName = 'ItemIndexService';
    var prototype = ItemIndexService.prototype, constructor = ItemIndexService;
    function ItemIndexService(externalDataSvc){
      this.externalDataSvc = externalDataSvc;
      this.loadAllEntries = bind$(this, 'loadAllEntries', prototype);
      this.loadAllBaseEntries = bind$(this, 'loadAllBaseEntries', prototype);
      this.loadAllArmorSetEntries = bind$(this, 'loadAllArmorSetEntries', prototype);
      this.findByArmorSet = bind$(this, 'findByArmorSet', prototype);
      this.findArmorSetFor = bind$(this, 'findArmorSetFor', prototype);
      this.findEntries = bind$(this, 'findEntries', prototype);
      this.findEntryByName = bind$(this, 'findEntryByName', prototype);
      this.findEntryByUid = bind$(this, 'findEntryByUid', prototype);
      this.clear = bind$(this, 'clear', prototype);
      this._index = [];
      this._armorSetIndex = [];
    }
    prototype.clear = function(){
      this._index.length = 0;
      delete this._index.$promise;
      this._armorSetIndex.length = 0;
      delete this._armorSetIndex.$promise;
      return this;
    };
    /**
     * Finds the first item matching a given filter.
     * @param byFilter Function filter function that takes item as
     * a parameter and returns true/false if it matches/doesn't.
     * @returns Promise that resolves with the found value.
     */
    prototype.findEntryByUid = function(uid){
      var this$ = this;
      return this.loadAllEntries().then(function(entries){
        var entry;
        entry = find(function(it){
          return it.uid === uid;
        })(
        entries);
        return entry;
      });
    };
    prototype.findEntryByName = function(name){
      var this$ = this;
      return this.loadAllEntries().then(function(entries){
        return find(function(it){
          return it.name === name;
        })(
        entries);
      });
    };
    prototype.findEntries = function(byFilter){
      var this$ = this;
      if (typeof byFilter !== 'function') {
        throw new Error("[byFilter] is not a function.");
      }
      return this.loadAllEntries().then(function(it){
        return filter(byFilter)(
        it);
      });
    };
    prototype.findArmorSetFor = function(item){
      var this$ = this;
      return this.loadAllArmorSetEntries().then(function(it){
        return find(function(it){
          return it.uid === item.uid;
        })(
        it);
      });
    };
    prototype.findByArmorSet = function(setName){
      var this$ = this;
      if (typeof setName === 'object') {
        setName = setName.name;
      }
      if (typeof setName !== 'string') {
        throw new Error("Armor set name must be a string, or an object with string property [name].");
      }
      return this.loadAllArmorSetEntries().then(function(sets){
        var armorIds, ref$;
        armorIds = (ref$ = find(function(it){
          return it.name === setName;
        })(
        sets)) != null ? ref$.armors : void 8;
        return this$.findEntries(function(entry){
          return any((function(it){
            return it === entry.id;
          }))(
          entry.itemType === 'armor' && armorIds);
        });
      });
    };
    prototype.loadAllArmorSetEntries = function(returnPromise){
      returnPromise == null && (returnPromise = true);
      if (this._armorSetIndex.$promise == null) {
        this._armorSetIndex = this.externalDataSvc.loadJson('/modules/items/content/armor-set-index.json', false);
      }
      return returnPromise
        ? this._armorSetIndex.$promise
        : this._armorSetIndex;
    };
    /**
     * Load all index entries that are not of upgraded weapons or armor.
     */
    prototype.loadAllBaseEntries = function(){
      var this$ = this;
      return this.loadAllEntries().then(function(entries){
        return reject(function(it){
          var ref$;
          return ((ref$ = it.itemType) === 'weapon' || ref$ === 'armor') && it.id % 100 > 0;
        })(
        entries);
      });
    };
    prototype.loadAllEntries = function(returnPromise){
      returnPromise == null && (returnPromise = true);
      if (this._index.$promise == null) {
        this._index = this.externalDataSvc.loadJson('/modules/items/content/index.json', false);
      }
      return returnPromise
        ? this._index.$promise
        : this._index;
    };
    return ItemIndexService;
  }());
  if (typeof module != 'undefined' && module !== null) {
    module.exports = ItemIndexService;
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);

},{}],24:[function(require,module,exports){
(function(){
  var ItemService;
  if (typeof angular != 'undefined' && angular !== null) {
    angular.module("dsc").service("itemSvc", function(externalDataSvc, itemIndexSvc, $q){
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t;
        return (t = typeof result)  == "object" || t == "function" ? result || child : child;
  })(ItemService, arguments, function(){});
    });
  }
  ItemService = (function(){
    ItemService.displayName = 'ItemService';
    var prototype = ItemService.prototype, constructor = ItemService;
    ItemService.WeaponStats = ['str', 'dex', 'int', 'fai'];
    ItemService.WeaponBonus = ['bonusStr', 'bonusDex', 'bonusInt', 'bonusFai'];
    ItemService.WeaponReqs = ['reqStr', 'reqDex', 'reqInt', 'reqFai'];
    ItemService.AttackTypes = ['atkPhy', 'atkMag', 'atkFir', 'atkLit'];
    ItemService.DpsTypes = ['dpsPhy', 'dpsMag', 'dpsFir', 'dpsLit'];
    ItemService.DefenceTypes = ['defPhy', 'defMag', 'defFir', 'defLit', 'defBlo', 'defTox', 'defCur'];
    ItemService.StaminaTypes = ['atkSta', 'defSta'];
    ItemService.EffectTypes = ['blo', 'tox', 'cur'];
    function ItemService(_externalDataSvc, _itemIndexSvc, $q){
      this._externalDataSvc = _externalDataSvc;
      this._itemIndexSvc = _itemIndexSvc;
      this.$q = $q;
      this.getUpgraded = bind$(this, 'getUpgraded', prototype);
      this.loadAll = bind$(this, 'loadAll', prototype);
      this.loadAllItems = bind$(this, 'loadAllItems', prototype);
      this.createItemModelFrom = bind$(this, 'createItemModelFrom', prototype);
      this.findAnyItemByUid = bind$(this, 'findAnyItemByUid', prototype);
      this.findItemById = bind$(this, 'findItemById', prototype);
      this.findItem = bind$(this, 'findItem', prototype);
      this.clear = bind$(this, 'clear', prototype);
      this.upgradeComp = new (require('./components/item-service-upgrade-component'));
      this.upgradeComp.constructor.apply(this.upgradeComp || (this.upgradeComp = {}), [this].concat(map(function(it){
        return it;
      })(
      arguments)));
      this._storage = {};
      this._models = require('./models/item-models');
    }
    prototype.clear = function(itemType){
      if (itemType == null) {
        this._storage = {};
      } else {
        this._storage[itemType].length = 0;
        delete this._storage[itemType].$promise;
      }
      return this;
    };
    /**
     * Return the first item matching a given filter
     * @param itemType String type of item to find.
     * @param filterFn Function Filter function
     * @return Promise that resolves with the found item, or null if nothing found.
     */
    prototype.findItem = function(itemType, filterFn){
      var this$ = this;
      if (typeof itemType !== 'string') {
        throw new Error("Item type is invalid or not provided");
      }
      return this.loadAllItems(itemType).then(function(items){
        var item;
        item = find(filterFn)(
        items);
        return item;
      });
    };
    prototype.findItemById = function(itemType, id){
      var this$ = this;
      return this.loadAllItems(itemType).then(function(items){
        var item;
        item = find(function(it){
          return it.id === id;
        })(
        items);
        if (item == null) {
          throw new Error("Failed to find [" + itemType + "] with ID [" + id + "].");
        }
        return item;
      });
    };
    /**
     * Finds any item, regardless of type, but can only
     * check fields that are in the index.
     */
    prototype.findAnyItemByUid = function(uid){
      var this$ = this;
      return this._itemIndexSvc.findEntryByUid(uid).then(function(item){
        var baseId, upLevel;
        if (item == null) {
          throw new Error("Failed to find item with UID [" + uid + "] in the item index.");
        }
        if (this$.upgradeComp.isUpgraded(item)) {
          baseId = this$.upgradeComp.getBaseIdFrom(item.id);
          upLevel = this$.upgradeComp.getUpgradeLevelFrom(item.id);
          return function(item, baseId, upLevel){
            return this$.findItemById(item.itemType, baseId).then(function(baseItem){
              return this$.getUpgraded(baseItem, upLevel);
            });
          }(item, baseId, upLevel);
        } else {
          return this$.findItemById(item.itemType, item.id);
        }
      });
    };
    /**
     * Create a model from given item data
     */
    prototype.createItemModelFrom = function(data){
      return (function(){
        switch (data.itemType) {
        case 'weapon':
          return new this._models.Weapon;
        case 'armor':
          return new this._models.Armor;
        case 'item':
          return new this._models.Item;
        default:
          throw new Error("Cannot create item model from data with .itemType == " + data.itemType + ".");
        }
      }.call(this)).useDataFrom(data);
    };
    /**
     * Load item data of a given item type.
     * @returns Promise or populated array, depending on returnPromise setting.
     */
    prototype.loadAllItems = function(itemType){
      var ref$, this$ = this;
      if (((ref$ = this._storage)[itemType] || (ref$[itemType] = [])).$promise == null) {
        this._storage[itemType].$promise = this._externalDataSvc.loadJson("/modules/items/content/" + itemType + "s.json").then(function(itemData){
          return this$.loadAll(itemType).from(itemData);
        });
      }
      return this._storage[itemType].$promise;
    };
    prototype.loadAll = function(itemType){
      var this$ = this;
      return {
        'from': function(itemData){
          var ref$;
          (ref$ = this$._storage)[itemType] || (ref$[itemType] = []);
          each(function(it){
            this$._storage[itemType].push(this$.createItemModelFrom(it));
          })(
          itemData);
          return this$._storage[itemType];
        }
      };
    };
    prototype.getUpgraded = function(item, level){
      var this$ = this;
      level == null && (level = true);
      if (level === true) {
        level = this.upgradeComp.getUpgradeLevelFrom(item.id) + 1;
      }
      return this.upgradeComp.findUpgradeFor(item, level).then(function(upgrade){
        if (upgrade == null) {
          return null;
        }
        return this$.upgradeComp.findBaseItem(
        item).then(function(baseItem){
          return this$.createItemModelFrom(baseItem);
        }).then(function(newItem){
          return this$.upgradeComp.apply(upgrade).to(newItem);
        }).then(function(newItem){
          return this$._itemIndexSvc.findEntryByUid(newItem.uid).then(function(entry){
            if (entry == null) {
              console.log(newItem);
              throw new Error("Failed to find index entry for the above item");
            }
            newItem.name = entry.name;
            return newItem;
          });
        }).then(function(newItem){
          if (newItem.itemType === 'armor') {
            newItem.armorSet = this$._itemIndexSvc.findArmorSetFor(newItem).name;
          }
          return newItem;
        });
      });
    };
    return ItemService;
  }());
  if (typeof module != 'undefined' && module !== null) {
    module.exports = ItemService;
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);

},{"./components/item-service-upgrade-component":21,"./models/item-models":27}],25:[function(require,module,exports){
(function(){
  angular.module("dsc").controller("ItemsController", function($scope, dataExportSvc, itemSvc, uiGridConstants){
    var i$, ref$, len$, itemType;
    $scope.itemTypes = [];
    for (i$ = 0, len$ = (ref$ = ['none', 'item', 'weapon', 'armor']).length; i$ < len$; ++i$) {
      itemType = ref$[i$];
      $scope.itemTypes.push(itemType);
    }
    require('./config/items-grid-options')($scope, uiGridConstants);
    $scope.selectedItemTypeChanged = function(){
      if ($scope.selectedItemType === 'none') {
        $scope.gridOptions.data = [];
        $scope.gridOptions.columnDefs = [];
        return;
      }
      $scope.gridOptions.columnDefs = $scope.columnConfigs[$scope.selectedItemType];
      itemSvc.loadAllItems($scope.selectedItemType).then(function(itemData){
        var i$, len$, weapon;
        if ($scope.selectedItemType === 'weapon') {
          for (i$ = 0, len$ = itemData.length; i$ < len$; ++i$) {
            weapon = itemData[i$];
            (fn$.call(this, weapon));
          }
        }
        $scope.gridOptions.data = itemData;
        function fn$(weapon){
          itemSvc.getUpgraded(weapon, 0).then(function(up){
            import$(weapon, up);
          });
        }
      });
    };
    $scope.exportAsJson = function(){
      dataExportSvc.exportJson(map(function(it){
        delete it.$$hashKey;
        return it;
      })(
      $scope.gridOptions.data));
    };
    $scope.exportAsCsv = function(){
      var outputData;
      outputData = map(function(it){
        var item;
        item = import$({}, it);
        delete item.$$hashKey;
        return item;
      })(
      $scope.gridOptions.data);
      dataExportSvc.exportCsv(outputData);
    };
    $scope.selectedItemType = 'none';
  });
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);

},{"./config/items-grid-options":22}],26:[function(require,module,exports){
(function(){
  require('./items-controller');
  require('./item-service');
  require('./item-index-service');
}).call(this);

},{"./item-index-service":23,"./item-service":24,"./items-controller":25}],27:[function(require,module,exports){
(function(){
  var ItemModel, EquipmentModel, WeaponModel, ArmorModel;
  if (typeof module != 'undefined' && module !== null) {
    module.exports = {
      'Item': ItemModel = (function(){
        ItemModel.displayName = 'ItemModel';
        var prototype = ItemModel.prototype, constructor = ItemModel;
        function ItemModel(){
          this.useDataFrom = bind$(this, 'useDataFrom', prototype);
          this.id = 0;
          this.itemType = null;
          this.itemSubtype = null;
          this.name = '';
          this.sellValue = 0;
          this.iconId = 0;
          this.sortId = 0;
        }
        /**
         * A unique ID that doesn't overlap between item types.
         */
        Object.defineProperty(prototype, 'uid', {
          get: function(){
            return this.itemType + this.id;
          },
          configurable: true,
          enumerable: true
        });
        prototype.useDataFrom = function(itemData){
          return import$(this, itemData);
        };
        return ItemModel;
      }()),
      'Equipment': EquipmentModel = (function(superclass){
        var prototype = extend$((import$(EquipmentModel, superclass).displayName = 'EquipmentModel', EquipmentModel), superclass).prototype, constructor = EquipmentModel;
        function EquipmentModel(){
          EquipmentModel.superclass.call(this);
          this.weight = 0.0;
          this.durability = 0;
          this.defPhy = 0;
          this.defMag = 0;
          this.defFir = 0;
          this.defLit = 0;
          this.defTox = 0;
          this.defBlo = 0;
          this.defCur = 0;
          this.matSetId = 0;
          this.upgradeCost = 0;
          this.upgradeId = -1;
        }
        return EquipmentModel;
      }(ItemModel)),
      'Weapon': WeaponModel = (function(superclass){
        var prototype = extend$((import$(WeaponModel, superclass).displayName = 'WeaponModel', WeaponModel), superclass).prototype, constructor = WeaponModel;
        function WeaponModel(){
          WeaponModel.superclass.call(this);
          this.itemType = 'weapon';
          this.weaponType = '';
          this.weaponSubtype = '';
          this.path = '';
          this.canBlock = false;
          this.canParry = false;
          this.casts = null;
          this.damagesGhosts = false;
          this.isAugmentable = false;
          this.dmgReg = false;
          this.dmgStrike = false;
          this.dmsSlash = false;
          this.dmgThrust = false;
          this.reqStr = 0;
          this.reqDex = 0;
          this.reqInt = 0;
          this.reqFai = 0;
          this.bonusStr = 0;
          this.bonusDex = 0;
          this.bonusInt = 0;
          this.bonusFai = 0;
          this.atkPhy = 0;
          this.atkMag = 0;
          this.atkFir = 0;
          this.atkLit = 0;
          this.atkSta = 0;
          this.defSta = 0;
          this.divine = 0;
          this.occult = 0;
          this.range = 0;
          this.atkBlo = 0;
          this.dmgBlo = 0;
          this.atkTox = 0;
          this.dmgTox = 0;
          this.atkHeal = 0;
          this.atkCosts = [];
        }
        Object.defineProperty(prototype, 'dpsPhy', {
          get: function(){
            return this._dpsFor(this.atkPhy);
          },
          configurable: true,
          enumerable: true
        });
        Object.defineProperty(prototype, 'dpsMag', {
          get: function(){
            return this._dpsFor(this.atkMag);
          },
          configurable: true,
          enumerable: true
        });
        Object.defineProperty(prototype, 'dpsFir', {
          get: function(){
            return this._dpsFor(this.atkFir);
          },
          configurable: true,
          enumerable: true
        });
        Object.defineProperty(prototype, 'dpsLit', {
          get: function(){
            return this._dpsFor(this.atkLit);
          },
          configurable: true,
          enumerable: true
        });
        return WeaponModel;
      }(EquipmentModel)),
      'Armor': ArmorModel = (function(superclass){
        var prototype = extend$((import$(ArmorModel, superclass).displayName = 'ArmorModel', ArmorModel), superclass).prototype, constructor = ArmorModel;
        function ArmorModel(){
          ArmorModel.superclass.call(this);
          this.itemType = 'armor';
          this.armorType = '';
          this.armorSet = '';
          this.defSlash = 0;
          this.defStrike = 0;
          this.defThrust = 0;
          this.defPoise = 0;
          this.staRegenMod = 0;
        }
        Object.defineProperty(prototype, 'sortType', {
          get: function(){
            switch (this.armorType) {
            case 'head':
              return 1;
            case 'chest':
              return 2;
            case 'hands':
              return 3;
            case 'legs':
              return 4;
            }
          },
          configurable: true,
          enumerable: true
        });
        return ArmorModel;
      }(EquipmentModel))
    };
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function extend$(sub, sup){
    function fun(){} fun.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new fun).constructor = sub;
    if (typeof sup.extended == 'function') sup.extended(sub);
    return sub;
  }
}).call(this);

},{}],28:[function(require,module,exports){
(function(){
  if (typeof module != 'undefined' && module !== null) {
    module.exports = function(uiGridConstants){
      return {
        enableFiltering: true,
        columnDefs: [
          {
            field: 'name',
            sort: {
              direction: uiGridConstants.ASC
            }
          }, {
            field: 'itemType',
            displayName: 'Type',
            filter: {
              type: uiGridConstants.filter.SELECT,
              selectOptions: [
                {
                  value: 'weapon',
                  label: "Weapons"
                }, {
                  value: 'armor',
                  label: "Armor"
                }, {
                  value: 'item',
                  label: "Items"
                }
              ]
            }
          }, {
            field: 'amount',
            width: 50
          }
        ]
      };
    };
  }
}).call(this);

},{}],29:[function(require,module,exports){
(function(){
  angular.module("dsc").filter("toStatArray", function(statSvc){
    var output;
    output = [];
    return function(model){
      if (output.length > 0) {
        return output;
      }
      statSvc.forEachStat(function(name, value){
        output.push({
          "name": name,
          "value": value
        });
      }, model);
      return output;
    };
  }).filter("fullStatName", function(statSvc){
    var output;
    output = {};
    return function(shortName){
      if (output[shortName] != null) {
        return output[shortName];
      }
      return output[shortName] = statSvc.fullStatNameOf(shortName);
    };
  });
}).call(this);

},{}],30:[function(require,module,exports){
(function(){
  var InventorySvc;
  if (typeof angular != 'undefined' && angular !== null) {
    angular.module("dsc").service("inventorySvc", function(itemSvc, storageSvc, itemIndexSvc, notificationSvc, $q){
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t;
        return (t = typeof result)  == "object" || t == "function" ? result || child : child;
  })(InventorySvc, arguments, function(){});
    });
  }
  InventorySvc = (function(){
    InventorySvc.displayName = 'InventorySvc';
    var prototype = InventorySvc.prototype, constructor = InventorySvc;
    function InventorySvc(_itemSvc, _storageSvc, _itemIndexSvc, _notificationSvc, $q){
      this._itemSvc = _itemSvc;
      this._storageSvc = _storageSvc;
      this._itemIndexSvc = _itemIndexSvc;
      this._notificationSvc = _notificationSvc;
      this.$q = $q;
      this.deductFrom = bind$(this, 'deductFrom', prototype);
      this.are = bind$(this, 'are', prototype);
      this.findAllAvailableUpgradesFor = bind$(this, 'findAllAvailableUpgradesFor', prototype);
      this.clear = bind$(this, 'clear', prototype);
      this.remove = bind$(this, 'remove', prototype);
      this.add = bind$(this, 'add', prototype);
      this.addByName = bind$(this, 'addByName', prototype);
      this.addAllByName = bind$(this, 'addAllByName', prototype);
      this.hasItemWithName = bind$(this, 'hasItemWithName', prototype);
      this.addAll = bind$(this, 'addAll', prototype);
      this.createInventoryItemFrom = bind$(this, 'createInventoryItemFrom', prototype);
      this.findItemsByType = bind$(this, 'findItemsByType', prototype);
      this.findItemByUid = bind$(this, 'findItemByUid', prototype);
      this.load = bind$(this, 'load', prototype);
      this.save = bind$(this, 'save', prototype);
      this._inventory = [];
      this._models = require('./models/inventory-models');
    }
    prototype.save = function(){
      var data, i$, ref$, len$, item;
      data = [];
      for (i$ = 0, len$ = (ref$ = this._inventory).length; i$ < len$; ++i$) {
        item = ref$[i$];
        data.push({
          'uid': item.uid,
          'amount': item.amount
        });
      }
      this._storageSvc.save('inventory', data);
    };
    prototype.load = function(){
      var promises, i$, ref$, ref1$, len$, data, promise, this$ = this;
      if (this._inventory.$promise == null) {
        this.clear();
        promises = [];
        for (i$ = 0, len$ = (ref$ = (ref1$ = this._storageSvc.load('inventory')) != null
          ? ref1$
          : []).length; i$ < len$; ++i$) {
          data = ref$[i$];
          promise = (fn$.call(this, data));
          promises.push(promise);
        }
        this._inventory.$promise = this.$q.all(promises).then(function(){
          return this$._inventory;
        });
      }
      return this._inventory.$promise;
      function fn$(data){
        var item, this$ = this;
        item = new this._models.InventoryItem(data);
        return this._itemIndexSvc.findEntryByUid(data.uid).then(function(indexEntry){
          item.useDataFrom(indexEntry);
          this$._inventory.push(item);
          return item;
        });
      }
    };
    prototype.findItemByUid = function(uid){
      var this$ = this;
      return this.load().then(function(inventory){
        return find(function(it){
          return it.uid === uid;
        })(
        inventory);
      });
    };
    /**
     * Return all items the inventory having a specific itemType
     */
    prototype.findItemsByType = function(type, subType){
      var this$ = this;
      subType == null && (subType = null);
      return this.load().then(function(inventory){
        return filter(function(it){
          return it.itemType === type;
        })(
        inventory);
      }).then(function(filtered){
        return this$.$q.all(map(function(it){
          return this$._itemSvc.findAnyItemByUid(it.uid);
        })(
        filtered));
      });
    };
    prototype.createInventoryItemFrom = function(item, amount){
      var x$;
      amount == null && (amount = 1);
      x$ = new this._models.InventoryItem;
      x$.useDataFrom(item);
      x$.amount = amount;
      return x$;
    };
    prototype.addAll = function(items){
      var invEntries, promises, i$, len$, entry, this$ = this;
      invEntries = map(function(it){
        if (it.amount == null) {
          return {
            item: it,
            amount: 1
          };
        } else {
          return it;
        }
      })(
      items);
      promises = [];
      for (i$ = 0, len$ = invEntries.length; i$ < len$; ++i$) {
        entry = invEntries[i$];
        promises.push(this.add(entry.item, entry.amount, false));
      }
      return this.$q.all(promises).then(function(){
        var itemList;
        itemList = join(', ')(
        map(function(it){
          return (it.amount > 1 ? it.amount + " of " : "") + "<strong>" + it.item.name + "</strong>";
        })(
        invEntries));
        this$._notificationSvc.addInfo("Added " + itemList + " to the inventory.");
      });
    };
    prototype.hasItemWithName = function(name){
      var this$ = this;
      return this.load().then(function(it){
        return any(function(it){
          return it.name === name;
        })(
        it);
      });
    };
    prototype.addAllByName = function(namesAndAmounts){
      var promises, i$, len$, entry, this$ = this;
      promises = [];
      for (i$ = 0, len$ = namesAndAmounts.length; i$ < len$; ++i$) {
        entry = namesAndAmounts[i$];
        (fn$.call(this, entry));
      }
      return this.$q.all(promises).then(function(items){
        var itemList;
        itemList = join(', ')(
        map(function(it){
          return "<strong>" + it.name + "</strong>";
        })(
        filter(function(it){
          return it != null;
        })(
        items)));
        if (itemList.length > 0) {
          this$._notificationSvc.addInfo("Added " + itemList + " to the inventory.");
        }
      });
      function fn$(entry){
        promises.push(this.addByName(entry.name, entry.amount, false));
      }
    };
    prototype.addByName = function(itemName, amount, notify){
      var this$ = this;
      amount == null && (amount = 1);
      notify == null && (notify = true);
      return this._itemIndexSvc.findEntryByName(itemName).then(function(item){
        if (item == null) {
          this$._notificationSvc.addError("Could not find item named '<strong>" + itemName + "</strong>', cannot add to inventory.");
          return null;
        }
        return this$.add(item, amount, notify);
      });
    };
    prototype.add = function(item, amount, notify){
      var this$ = this;
      amount == null && (amount = 1);
      notify == null && (notify = true);
      return this.findItemByUid(item.uid).then(function(invItem){
        var x$;
        if (invItem != null) {
          invItem.amount += amount;
        } else {
          x$ = invItem = this$.createInventoryItemFrom(item, amount);
          this$._inventory.push(
          x$);
        }
        if (notify) {
          this$._notificationSvc.addInfo("Added " + (amount > 1 ? amount + " of " : "") + "<strong>" + invItem.name + "</strong> to the inventory.");
        }
        this$.save();
        return invItem;
      });
    };
    prototype.remove = function(item, amount){
      var this$ = this;
      amount == null && (amount = 1);
      return this.findItemByUid(item.uid).then(function(entry){
        if (entry == null) {
          throw new Error("Failed to remove the above item because couldn't find it in the inventory.");
        }
        entry.amount = amount === true
          ? 0
          : entry.amount -= amount;
        if (entry.amount < 1) {
          this$._inventory.splice(this$._inventory.indexOf(entry), 1);
        }
        this$.save();
        return entry;
      });
    };
    prototype.clear = function(){
      this._inventory.length = 0;
      delete this._inventory.$promise;
      return this;
    };
    /**
     * Find all upgrades that can be applied to a given item,
     * within the limits of what is available to the user
     */
    prototype.findAllAvailableUpgradesFor = function(item){
      var up, x$, upgradeList, maxUpgrades, this$ = this;
      up = this._itemSvc.upgradeComp;
      up.ensureItCanBeUpgraded(
      item);
      if (item.id == null) {
        throw new Error("Can't find upgrades for an item with no ID.");
      }
      if (item.id < 0 || item.upgradeId < 0) {
        x$ = this.$q.defer();
        x$.resolve([]);
        return x$.promise;
      }
      upgradeList = [];
      maxUpgrades = item.itemType === 'weapon' ? 15 : 10;
      return this.load().then(function(inventory){
        var materials, promise, canKeepUpgrading, i$, to$, level;
        materials = map(function(it){
          return import$({}, it);
        })(
        filter(function(it){
          return it.itemType === 'item';
        })(
        inventory));
        promise = this$.$q(function(resolve, reject){
          resolve();
        });
        canKeepUpgrading = true;
        if (this$._debugLog) {
          console.log("Item's current upgrade level is " + up.getUpgradeLevelFrom(item.id));
        }
        for (i$ = up.getUpgradeLevelFrom(item.id) + 1, to$ = maxUpgrades; i$ <= to$; ++i$) {
          level = i$;
          fn$(materials, level);
        }
        return promise;
        function fn$(materials, level){
          promise = promise.then(function(){
            if (!canKeepUpgrading) {
              return null;
            }
            if (this$._debugLog) {
              console.log("Checking upgrade level " + level);
            }
            return this$.$q.all([up.canBeUpgradedFurther(item), this$.are(materials).enoughToUpgrade(item, level)]);
          }).then(function(canUpgrade){
            if (this$._debugLog && canUpgrade != null) {
              console.log("Can upgrade further: " + canUpgrade[0]);
              console.log("Enough materials: " + canUpgrade[1]);
            }
            if (!((canUpgrade != null && canUpgrade[0]) && (canUpgrade != null && canUpgrade[1]))) {
              materials.length = 0;
              canKeepUpgrading = false;
              return null;
            }
            if (canUpgrade = canUpgrade[0] + canUpgrade[1]) {
              return this$.$q.all([this$._itemSvc.getUpgraded(item, level), this$.deductFrom(materials).costOfUpgrade(item, level)]);
            }
          }).then(function(result){
            var upItem, cost, totalCost, costEntry, x$;
            upItem = result != null ? result[0] : void 8;
            cost = result != null ? result[1] : void 8;
            if (upItem != null) {
              totalCost = materials.totalCost || (materials.totalCost = []);
              costEntry = find(function(it){
                return it.matId === cost.matId;
              })(
              totalCost);
              if (costEntry == null) {
                costEntry = {
                  matId: cost.matId,
                  matCost: 0
                };
                totalCost.push(costEntry);
              }
              costEntry.matCost += cost.matCost;
              x$ = upItem;
              x$.totalCost = map(function(it){
                return import$({}, it);
              })(
              totalCost);
              x$.upgradeLevel = level - up.getUpgradeLevelFrom(item.id);
              upgradeList.push(upItem);
            }
          });
        }
      }).then(function(){
        return upgradeList;
      });
    };
    prototype.are = function(materials){
      var up, this$ = this;
      up = this._itemSvc.upgradeComp;
      return {
        enoughToUpgrade: function(item, level){
          return up.findUpgradeFor(item, level).then(function(upgrade){
            if (upgrade == null) {
              return false;
            }
            return up.findUpgradeMaterialsFor(item, upgrade);
          }).then(function(materialSet){
            if (materialSet === null) {
              return false;
            }
            if (materialSet == null) {
              console.log("Failed to find material set for", import$({}, item), level);
            }
            if (materialSet.matId < 0 || materialSet.matCost < 0) {
              return true;
            }
            return any(function(it){
              return it.id === materialSet.matId && it.amount >= materialSet.matCost;
            })(
            materials);
          });
        }
      };
    };
    prototype.deductFrom = function(materials){
      var up, this$ = this;
      up = this._itemSvc.upgradeComp;
      return {
        costOfUpgrade: function(item, level){
          return up.findUpgradeFor(item, level).then(function(upgrade){
            return up.findUpgradeMaterialsFor(item, upgrade);
          }).then(function(materialSet){
            var material;
            if (materialSet.matId >= 0 && materialSet.matCost >= 0) {
              material = find(function(it){
                return it.id === materialSet.matId;
              })(
              materials);
              if (material == null) {
                console.log(materialSet.matId, materials);
              }
              material.amount -= materialSet.matCost;
            }
            return {
              matCost: materialSet.matCost,
              matId: materialSet.matId
            };
          });
        }
      };
    };
    return InventorySvc;
  }());
  if (typeof module != 'undefined' && module !== null) {
    module.exports = InventorySvc;
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);

},{"./models/inventory-models":32}],31:[function(require,module,exports){
(function(){
  angular.module("dsc");
  require("./inventory-service");
  require("./stat-service");
  require("./filters/stat-filters");
  require("./pc-controller");
}).call(this);

},{"./filters/stat-filters":29,"./inventory-service":30,"./pc-controller":33,"./stat-service":34}],32:[function(require,module,exports){
(function(){
  var InventoryItemModel;
  InventoryItemModel = (function(){
    InventoryItemModel.displayName = 'InventoryItemModel';
    var prototype = InventoryItemModel.prototype, constructor = InventoryItemModel;
    function InventoryItemModel(item){
      this.useDataFrom = bind$(this, 'useDataFrom', prototype);
      this.amount = 1;
      this.name = '';
      this.itemType = null;
      this.id = '';
      this.uid = '';
      this.useDataFrom(item);
    }
    prototype.useDataFrom = function(item){
      var i$, ref$, len$, field;
      if (item == null) {
        return;
      }
      for (i$ = 0, len$ = (ref$ = ['amount', 'uid', 'name', 'itemType', 'id']).length; i$ < len$; ++i$) {
        field = ref$[i$];
        if (item[field] != null) {
          this[field] = item[field];
        }
      }
      return this;
    };
    return InventoryItemModel;
  }());
  if (typeof module != 'undefined' && module !== null) {
    module.exports = {
      'InventoryItem': InventoryItemModel
    };
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);

},{}],33:[function(require,module,exports){
(function(){
  var PcController;
  if (typeof angular != 'undefined' && angular !== null) {
    angular.module("dsc").controller("pcController", function($scope, uiGridConstants, statSvc, itemSvc, itemIndexSvc, storageSvc, inventorySvc){
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t;
        return (t = typeof result)  == "object" || t == "function" ? result || child : child;
  })(PcController, arguments, function(){});
    });
  }
  PcController = (function(){
    PcController.displayName = 'PcController';
    var prototype = PcController.prototype, constructor = PcController;
    function PcController($scope, $uiGridConstants, _statSvc, _itemSvc, _itemIndexSvc, _storageSvc, _inventorySvc){
      this.$scope = $scope;
      this.$uiGridConstants = $uiGridConstants;
      this._statSvc = _statSvc;
      this._itemSvc = _itemSvc;
      this._itemIndexSvc = _itemIndexSvc;
      this._storageSvc = _storageSvc;
      this._inventorySvc = _inventorySvc;
      this.setUpgradeableStatus = bind$(this, 'setUpgradeableStatus', prototype);
      this.saveUserData = bind$(this, 'saveUserData', prototype);
      this.upgrade = bind$(this, 'upgrade', prototype);
      this.addArmorSet = bind$(this, 'addArmorSet', prototype);
      this.addNewItem = bind$(this, 'addNewItem', prototype);
      this.add = bind$(this, 'add', prototype);
      this.wireUp = bind$(this, 'wireUp', prototype);
      this.load = bind$(this, 'load', prototype);
      this.setup = bind$(this, 'setup', prototype);
      this.setup();
      this.load();
      this.wireUp();
    }
    prototype.setup = function(){
      var ref$, this$ = this;
      ref$ = this.$scope;
      ref$.userData = {
        stats: {},
        inventory: [],
        gridState: {}
      };
      ref$.selectedItem = null;
      ref$.armorSets = [];
      ref$.allItems = [];
      ref$.itemTypes = ['weapon', 'armor', 'item'];
      this.$scope.gridOptions = require('./config/inventory-grid-opts')(this.$uiGridConstants);
      this.$scope.gridOptions.onRegisterApi = function(gridApi){
        this$.$scope.gridApi = gridApi;
        gridApi.core.addRowHeaderColumn({
          name: 'rowHeaderCol',
          displayName: '',
          width: 100,
          cellTemplate: 'GridRowHeader.html'
        });
        gridApi.core.on.filterChanged(this$.$scope, function(){
          this$._storageSvc.save("pc.grid-state", this$.$scope.gridApi.saveState.save());
        });
        gridApi.core.on.rowsRendered(this$.$scope, function(){
          if (this$.$scope.gridState == null) {
            this$.$scope.gridState = this$._storageSvc.load('pc.grid-state');
            this$.$scope.gridApi.saveState.restore(this$.$scope, this$.$scope.gridState);
          }
        });
      };
    };
    prototype.load = function(){
      var this$ = this;
      this._itemIndexSvc.loadAllArmorSetEntries().then(function(armorSets){
        this$.$scope.armorSets = armorSets;
      });
      this._itemIndexSvc.loadAllBaseEntries().then(function(entries){
        this$.$scope.allItems = entries;
        return this$._inventorySvc.clear().load();
      }).then(function(inv){
        this$.$scope.userData.inventory = this$.$scope.gridOptions.data = inv;
        this$.setUpgradeableStatus();
      });
      this.$scope.userData.stats = this._statSvc.loadUserData();
    };
    prototype.wireUp = function(){
      var i$, ref$, len$, func;
      for (i$ = 0, len$ = (ref$ = ['canUpgrade', 'upgrade', 'addArmorSet', 'addNewItem', 'saveUserData', 'add']).length; i$ < len$; ++i$) {
        func = ref$[i$];
        this.$scope[func] = this[func];
      }
      for (i$ = 0, len$ = (ref$ = ['remove']).length; i$ < len$; ++i$) {
        func = ref$[i$];
        this.$scope[func] = this._inventorySvc[func];
      }
    };
    prototype.add = function(item){
      var this$ = this;
      this._inventorySvc.add(item).then(function(){
        this$.setUpgradeableStatus();
      });
    };
    prototype.addNewItem = function(selection){
      this.$scope.add(selection.originalObject);
    };
    prototype.addArmorSet = function(selection){
      var armorSet, this$ = this;
      armorSet = selection.originalObject;
      this._itemIndexSvc.findByArmorSet(armorSet).then(function(armors){
        this$._inventorySvc.addAll(armors);
      });
    };
    prototype.upgrade = function(invEntry){
      var this$ = this;
      this._itemSvc.findAnyItemByUid(invEntry.uid).then(function(item){
        return this$._itemSvc.getUpgraded(item);
      }).then(function(upItem){
        if (upItem == null) {
          return;
        }
        this$.$scope.remove(invEntry);
        this$.$scope.add(upItem);
      });
    };
    prototype.saveUserData = function(){
      this._statSvc.saveUserData(this.$scope.userData.stats);
    };
    prototype.setUpgradeableStatus = function(){
      var i$, ref$, len$, invItem;
      for (i$ = 0, len$ = (ref$ = this.$scope.userData.inventory).length; i$ < len$; ++i$) {
        invItem = ref$[i$];
        if (invItem.canBeUpgraded != null) {
          continue;
        }
        if (!this._itemSvc.upgradeComp.canBeUpgraded(
        invItem)) {
          invItem.canBeUpgraded = false;
          continue;
        }
        (fn$.call(this, invItem));
      }
      function fn$(inventoryItem){
        var this$ = this;
        this._itemSvc.findAnyItemByUid(inventoryItem.uid).then(function(realItem){
          inventoryItem.canBeUpgraded = this$._itemSvc.upgradeComp.canBeUpgradedFurther(realItem);
        });
      }
    };
    return PcController;
  }());
  if (typeof module != 'undefined' && module !== null) {
    module.exports = PcController;
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);

},{"./config/inventory-grid-opts":28}],34:[function(require,module,exports){
(function(){
  var StatService;
  if (typeof angular != 'undefined' && angular !== null) {
    angular.module("dsc").service("statSvc", function(storageSvc){
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t;
        return (t = typeof result)  == "object" || t == "function" ? result || child : child;
  })(StatService, arguments, function(){});
    });
  }
  StatService = (function(){
    StatService.displayName = 'StatService';
    var prototype = StatService.prototype, constructor = StatService;
    StatService.allStats = ['vit', 'att', 'end', 'str', 'dex', 'res', 'int', 'fai', 'hum'];
    StatService.statNames = ['Vitality', 'Attunement', 'Endurance', 'Strength', 'Dexterity', 'Resistance', 'Intelligence', 'Faith', 'Humanity'];
    StatService.weaponStats = ['str', 'dex', 'int', 'fai'];
    function StatService(_storageSvc){
      this._storageSvc = _storageSvc;
      this.statScalingFactorOf = bind$(this, 'statScalingFactorOf', prototype);
      this.saveUserData = bind$(this, 'saveUserData', prototype);
      this.loadUserData = bind$(this, 'loadUserData', prototype);
      this.forEachStat = bind$(this, 'forEachStat', prototype);
      this.statValueOf = bind$(this, 'statValueOf', prototype);
      this.fullStatNameOf = bind$(this, 'fullStatNameOf', prototype);
      this.data = {};
    }
    prototype.fullStatNameOf = function(shortName){
      return constructor.statNames[constructor.allStats.indexOf(shortName)];
    };
    prototype.statValueOf = function(name){
      this.loadUserData();
      return this.data[name];
    };
    prototype.forEachStat = function(func, model){
      var i$, ref$, len$, statName, statValue, ref1$;
      model == null && (model = this.data);
      for (i$ = 0, len$ = (ref$ = constructor.allStats).length; i$ < len$; ++i$) {
        statName = ref$[i$];
        statValue = model[statName];
        model[statName] = (ref1$ = func(statName, statValue)) != null ? ref1$ : statValue;
      }
    };
    prototype.loadUserData = function(){
      var data, ref$, model, i$, len$, name, ref1$;
      data = (ref$ = this._storageSvc.load('pc.stats')) != null
        ? ref$
        : {};
      model = {};
      for (i$ = 0, len$ = (ref$ = constructor.allStats).length; i$ < len$; ++i$) {
        name = ref$[i$];
        model[name] = +((ref1$ = data[name]) != null ? ref1$ : 8);
      }
      return this.data = model;
    };
    prototype.saveUserData = function(model){
      model == null && (model = this.data);
      this._storageSvc.save('pc.stats', model);
    };
    prototype.statScalingFactorOf = function(name){
      var statValue, thresholds, result, i$, len$, threshold;
      statValue = this.statValueOf(name);
      thresholds = (function(){
        switch (name) {
        case 'str':
          // fallthrough
        case 'dex':
          return [[10, 0.5], [10, 3.5], [20, 2.25]];
        case 'int':
          // fallthrough
        case 'fai':
          return [[10, 0.5], [20, 2.25], [20, 1.5]];
        default:
          throw Error('unimplemented');
        }
      }());
      result = 0;
      for (i$ = 0, len$ = thresholds.length; i$ < len$; ++i$) {
        threshold = thresholds[i$];
        if (statValue >= threshold[0]) {
          result += threshold[0] * threshold[1];
        } else {
          result += statValue * threshold[1];
        }
        statValue -= threshold[0];
        if (statValue < 1) {
          break;
        }
      }
      result /= 100;
      return result;
    };
    return StatService;
  }());
  if (typeof module != 'undefined' && module !== null) {
    module.exports = StatService;
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);

},{}],35:[function(require,module,exports){
(function(){
  require('./tracker-service');
  require('./tracker-controller');
}).call(this);

},{"./tracker-controller":36,"./tracker-service":37}],36:[function(require,module,exports){
(function(){
  var TrackerController;
  if (typeof angular != 'undefined' && angular !== null) {
    angular.module("dsc").controller("trackerController", function($location, $routeParams, $sce, $scope, trackerSvc, notificationSvc, inventorySvc, $q){
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t;
        return (t = typeof result)  == "object" || t == "function" ? result || child : child;
  })(TrackerController, arguments, function(){});
    });
  }
  TrackerController = (function(){
    TrackerController.displayName = 'TrackerController';
    var prototype = TrackerController.prototype, constructor = TrackerController;
    function TrackerController($location, $routeParams, $sce, $scope, _trackerSvc, _notificationSvc, _inventorySvc, $q){
      this.$location = $location;
      this.$routeParams = $routeParams;
      this.$sce = $sce;
      this.$scope = $scope;
      this._trackerSvc = _trackerSvc;
      this._notificationSvc = _notificationSvc;
      this._inventorySvc = _inventorySvc;
      this.$q = $q;
      this.addItemsFrom = bind$(this, 'addItemsFrom', prototype);
      this.set = bind$(this, 'set', prototype);
      this.checkAvailability = bind$(this, 'checkAvailability', prototype);
      this.process = bind$(this, 'process', prototype);
      this.expandOrCollapse = bind$(this, 'expandOrCollapse', prototype);
      this.performActionOn = bind$(this, 'performActionOn', prototype);
      this.wireUp = bind$(this, 'wireUp', prototype);
      this.loadUp = bind$(this, 'loadUp', prototype);
      this.setUp = bind$(this, 'setUp', prototype);
      this.setUp();
      this.wireUp();
      this.loadUp();
    }
    prototype.setUp = function(){
      var this$ = this;
      this.$scope.allAreas = [
        {
          key: 'asylum',
          name: "Northern Undead Asylum"
        }, {
          key: 'blight',
          name: "Blighttown"
        }, {
          key: 'darkroot-garden',
          name: "Darkroot Garden"
        }, {
          key: 'sen',
          name: "Sen's Fortress"
        }, {
          key: 'londo',
          name: "Anor Londo"
        }, {
          key: 'ariamis',
          name: "Painted World of Ariamis"
        }
      ];
      this.$scope.currentArea = Obj.find(function(it){
        return it.key === this$.$routeParams['area'];
      })(
      this.$scope.allAreas);
      if (this.$scope.currentArea == null) {
        this.$location.path("/tracker");
      }
      this.$scope.areaContent = [];
      this.$scope.selectedArea = null;
      this.$scope.entryIndex = {};
      this.$scope.globals = {
        "enemies": {},
        "npcs": [],
        "vars": {
          "asylum-done": false,
          "pc-class": null
        }
      };
    };
    prototype.loadUp = function(){
      var this$ = this;
      this._trackerSvc.loadAreaContent(this.$scope.currentArea.key).then(function(content){
        each(function(it){
          return this$.process(it);
        })(
        content);
        this$.checkAvailability(content);
        this$.$scope.areaContent = content;
        return this$.$scope.entry = {
          children: content
        };
      });
    };
    prototype.wireUp = function(){
      var i$, ref$, len$, func, this$ = this;
      for (i$ = 0, len$ = (ref$ = ['performActionOn', 'expandOrCollapse']).length; i$ < len$; ++i$) {
        func = ref$[i$];
        this.$scope[func] = this[func];
      }
      this.$scope.$watch("selectedArea", function(value){
        if ((value != null ? value.originalObject : void 8) == null) {
          return;
        }
        this$.$location.path("/tracker/" + value.originalObject.key);
      });
    };
    prototype.performActionOn = function(entry){
      var def, ref$, key$, ref1$, this$ = this;
      def = this.$q.defer();
      switch (entry.action) {
      case 'kill':
        ((ref$ = (ref1$ = this.$scope.globals).enemies || (ref1$.enemies = {}))[key$ = entry.title] || (ref$[key$] = {})).isDead = true;
        def.resolve();
        break;
      case 'pick-up':
        def.promise = this.addItemsFrom(entry['title']);
        break;
      default:
        def.resolve();
      }
      return def.promise.then(function(){
        var parts, name, value, ref$;
        if (entry['setVar'] != null) {
          parts = entry['setVar'].split('|');
          switch (parts[0]) {
          case 'global':
            parts = parts[1].split(':');
            name = parts[0];
            value = (ref$ = parts[1]) != null ? ref$ : true;
            this$.$scope.globals['vars'][name] = value;
          }
        }
        if (entry['items'] != null) {
          return this$.addItemsFrom(entry['items']);
        }
      }).then(function(){
        entry.meta.isHidden = true;
        this$.checkAvailability();
      });
    };
    prototype.expandOrCollapse = function($event, entry){
      $event.stopPropagation();
      return entry.meta.isCollapsed = !entry.meta.isCollapsed;
    };
    prototype.process = function(entry){
      var x$, ref$, y$, this$ = this;
      x$ = entry.meta || (entry.meta = {});
      x$.isCollapsed = (ref$ = (x$.userData || (x$.userData = {})).isCollapsed) != null
        ? ref$
        : in$('spoiler', entry.labels);
      x$.isHidden = (ref$ = (x$.userData || (x$.userData = {})).isHidden) != null ? ref$ : false;
      x$.isExpandable = entry.children != null || entry.content != null;
      y$ = x$.additionalClasses = [];
      y$.push((entry.children != null ? "with" : "without") + "-children");
      y$.push((entry.content != null ? "with" : "without") + "-content");
      if (in$('enemy', entry.labels)) {
        entry.action == null && (entry.action = 'kill');
      }
      if (in$('item', entry.labels)) {
        entry.action == null && (entry.action = 'pick-up');
      }
      if (entry.children != null) {
        each(function(it){
          return this$.process(it);
        })(
        entry.children);
      }
      entry.content = this.$sce.trustAsHtml(entry.content);
      ((ref$ = this.$scope).entryIndex || (ref$.entryIndex = {}))[entry.id] = entry;
    };
    prototype.checkAvailability = function(entries){
      var i$, len$, entry;
      entries == null && (entries = this.$scope.areaContent);
      for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
        entry = entries[i$];
        (fn$.call(this, entry));
      }
      function fn$(entry){
        var def, ref$, this$ = this;
        entry.meta.additionalClasses = reject((function(it){
          return it === 'unavailable';
        }))(
        entry.meta.additionalClasses);
        def = this.$q.defer();
        if (((ref$ = entry.parent) != null ? ref$.meta : void 8) != null && entry.parent.meta.isAvailable === false) {
          def.resolve(false);
        } else if (entry['if'] != null) {
          if (typeof entry['if'] === 'string') {
            entry['if'] = [entry['if']];
          }
          if (entry['if'].constructor !== Array) {
            console.log(entry);
            throw new Error("Can't process the above entry's [.if] property");
          }
          def.promise = this.$q.all(map(function(requirement){
            return this$.set(entry).availabilityAccordingTo(requirement);
          })(
          entry['if']));
        } else {
          def.resolve(true);
        }
        def.promise.then(function(isAvailable){
          isAvailable = all((function(it){
            return it === true;
          }))(
          [].concat(isAvailable));
          if (!isAvailable) {
            entry.meta.additionalClasses.push('unavailable');
          }
          entry.meta.isAvailable = isAvailable;
          if (entry.children != null) {
            return this$.checkAvailability(entry.children);
          }
        });
      }
    };
    prototype.set = function(entry){
      var this$ = this;
      return {
        availabilityAccordingTo: function(req){
          var def, parts, inverse, name, value, ref$, shouldBeDead, ref1$;
          def = this$.$q.defer();
          parts = req.split('|');
          inverse = parts[parts.length - 1] === 'not';
          switch (parts[0]) {
          case 'global':
            parts = parts[1].split(':');
            name = parts[0];
            value = (ref$ = parts[1]) != null ? ref$ : true;
            def.resolve((this$.$scope.globals['vars'][name] === value) !== inverse);
            break;
          case 'item':
            def.promise = this$._inventorySvc.hasItemWithName(parts[1]);
            break;
          case 'enemy':
            name = parts[1];
            shouldBeDead = ((ref$ = parts[2]) != null ? ref$ : 'alive') === 'dead';
            if (inverse) {
              shouldBeDead = !shouldBeDead;
            }
            def.resolve(((ref$ = (ref1$ = this$.$scope.globals['enemies'][name]) != null ? ref1$.isDead : void 8) != null ? ref$ : false) === shouldBeDead);
            break;
          default:
            throw new Error("Unrecognized condition: '" + req + "'");
          }
          return def.promise.then(function(isAvailable){
            if (isAvailable !== entry.meta.isAvailable) {
              entry.meta.isCollapsed = !isAvailable;
            }
            return isAvailable;
          });
        }
      };
    };
    prototype.addItemsFrom = function(text){
      var promises, potentials, batch, i$, len$, potential, result, ref$;
      promises = [];
      potentials = map(function(it){
        return it.trim();
      })(
      text.split(','));
      batch = [];
      for (i$ = 0, len$ = potentials.length; i$ < len$; ++i$) {
        potential = potentials[i$];
        result = /([^()]+)(?:\s+\((\d+)\)|$)/.exec(potential);
        batch.push({
          name: result[1],
          amount: (ref$ = result[2]) != null ? ref$ : 1
        });
      }
      promises.push(this._inventorySvc.addAllByName(batch));
      return this.$q.all(promises);
    };
    return TrackerController;
  }());
  if (typeof module != 'undefined' && module !== null) {
    module.exports = TrackerController;
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);

},{}],37:[function(require,module,exports){
(function(){
  var TrackerService;
  if (typeof angular != 'undefined' && angular !== null) {
    angular.module("dsc").service("trackerSvc", function(externalDataSvc){
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t;
        return (t = typeof result)  == "object" || t == "function" ? result || child : child;
  })(TrackerService, arguments, function(){});
    });
  }
  TrackerService = (function(){
    TrackerService.displayName = 'TrackerService';
    var prototype = TrackerService.prototype, constructor = TrackerService;
    function TrackerService(_externalDataSvc){
      this._externalDataSvc = _externalDataSvc;
      this.process = bind$(this, 'process', prototype);
      this.loadAreaContent = bind$(this, 'loadAreaContent', prototype);
    }
    prototype.loadAreaContent = function(area){
      var this$ = this;
      return this._externalDataSvc.loadJson("/modules/tracker/content/areas/" + area + ".json").then(function(it){
        return this$.process(it);
      });
    };
    prototype.process = function(entry, parent){
      var output, text, ref$, this$ = this;
      if (entry.constructor === Array) {
        output = map(function(it){
          return this$.process(it);
        })(
        entry);
      } else {
        output = import$({}, entry);
        if (typeof (output.labels || (output.labels = [])) === 'string') {
          output.labels = [output.labels];
        }
        if (output['items'] != null) {
          text = "<strong>Items:</strong> " + join(', ')(
          [].concat(output['items'])) + "<br />";
          output.content = text + ((ref$ = output.content) != null ? ref$ : "");
        }
        if (output.children != null) {
          output.children = map(function(it){
            return this$.process(it, output);
          })(
          output.children);
        }
        output.parent = parent;
      }
      return output;
    };
    return TrackerService;
  }());
  if (typeof module != 'undefined' && module !== null) {
    module.exports = TrackerService;
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);

},{}],38:[function(require,module,exports){
(function(){
  if (typeof module != 'undefined' && module !== null) {
    module.exports = function(uiGridConstants){
      var percentFieldMinWidth;
      percentFieldMinWidth = 45;
      return {
        columnDefs: [
          {
            field: 'score',
            minWidth: 50,
            cellFilter: 'number:2',
            sort: {
              direction: uiGridConstants.DESC,
              priority: 1
            },
            type: 'number'
          }, {
            field: 'name',
            minWidth: 210,
            displayName: 'Name'
          }, {
            field: 'statReqs',
            displayName: 'Requirements',
            minWidth: 50
          }, {
            field: 'dps',
            displayName: 'DPS',
            minWidth: 50
          }, {
            field: 'atk',
            displayName: 'ATK',
            minWidth: 50
          }, {
            field: 'def',
            displayName: 'DEF',
            minWidth: 50
          }
        ]
      };
    };
  }
}).call(this);

},{}],39:[function(require,module,exports){
(function(){
  angular.module("dsc").filter("statName", function(statSvc){
    return function(name){
      if (name.indexOf('req') === 0) {
        name = name.substr(3);
      }
      return name;
    };
  });
}).call(this);

},{}],40:[function(require,module,exports){
(function(){
  require('./weapon-finder-service');
  require('./filters/weapon-finder-filters');
  require('./weapon-finder-controller');
}).call(this);

},{"./filters/weapon-finder-filters":39,"./weapon-finder-controller":41,"./weapon-finder-service":42}],41:[function(require,module,exports){
(function(){
  var WeaponFinderController;
  if (typeof angular != 'undefined' && angular !== null) {
    angular.module("dsc").controller("weaponFinderController", function($scope, storageSvc, weaponFinderSvc, uiGridConstants, statSvc, itemSvc){
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t;
        return (t = typeof result)  == "object" || t == "function" ? result || child : child;
  })(WeaponFinderController, arguments, function(){});
    });
  }
  WeaponFinderController = (function(){
    WeaponFinderController.displayName = 'WeaponFinderController';
    var prototype = WeaponFinderController.prototype, constructor = WeaponFinderController;
    function WeaponFinderController($scope, _storageSvc, _weaponFinderSvc, $uiGridConstants, _statSvc, _itemSvc){
      this.$scope = $scope;
      this._storageSvc = _storageSvc;
      this._weaponFinderSvc = _weaponFinderSvc;
      this.$uiGridConstants = $uiGridConstants;
      this._statSvc = _statSvc;
      this._itemSvc = _itemSvc;
      this.findWeapons = bind$(this, 'findWeapons', prototype);
      this.copyStatsToReqs = bind$(this, 'copyStatsToReqs', prototype);
      this.wireUp = bind$(this, 'wireUp', prototype);
      this.load = bind$(this, 'load', prototype);
      this.setup = bind$(this, 'setup', prototype);
      this.setup();
      this.load();
      this.wireUp();
    }
    prototype.setup = function(){
      var i$, a, ref$, ref1$;
      this.$scope.results = [];
      this.$scope.paramSetNames = ['weapon', 'shield'];
      this.$scope.statArray = this._weaponFinderSvc.statArray;
      this.$scope.reqLimitArray = this._statSvc.constructor.weaponStats;
      this.$scope.dpsCalcOptions = ["One-hand light", "One-hand heavy", "Two-hand light", "Two-hand heavy"];
      for (i$ = 0; i$ <= 1; ++i$) {
        a = i$;
        import$((ref$ = (ref1$ = this.$scope).paramSets || (ref1$.paramSets = []))[a] || (ref$[a] = {}), this._weaponFinderSvc.params);
      }
      this.$scope.gridOptions = require('./config/weapon-finder-grid-options')(this.$uiGridConstants);
    };
    prototype.load = function(){
      var userSets, ref$, i$, len$, a, set;
      userSets = (ref$ = this._storageSvc.load('weapon-finder.param-sets')) != null
        ? ref$
        : [];
      console.log(userSets);
      for (i$ = 0, len$ = (ref$ = this.$scope.paramSets).length; i$ < len$; ++i$) {
        a = i$;
        set = ref$[i$];
        import$(this.$scope.paramSets[a], userSets[a]);
      }
      this.$scope.params = this.$scope.paramSets[0];
    };
    prototype.wireUp = function(){
      var i$, ref$, len$, func, this$ = this;
      for (i$ = 0, len$ = (ref$ = ['findWeapons', 'copyStatsToReqs']).length; i$ < len$; ++i$) {
        func = ref$[i$];
        this.$scope[func] = this[func];
      }
      this.$scope.$watch("paramSets", function(){
        this$._storageSvc.save("weapon-finder.param-sets", this$.$scope.paramSets);
      }, true);
    };
    prototype.copyStatsToReqs = function(){
      var i$, ref$, len$, key;
      for (i$ = 0, len$ = (ref$ = ['str', 'dex', 'int', 'fai']).length; i$ < len$; ++i$) {
        key = ref$[i$];
        this.$scope.params.reqLimits[key] = this._statSvc.statValueOf(key);
      }
    };
    prototype.findWeapons = function(){
      var this$ = this;
      import$(this._weaponFinderSvc.params, this.$scope.params);
      this._weaponFinderSvc.findBestWeapons().then(function(results){
        this$.$scope.results = map(function(result){
          return result.statReqs = join('/')(
          map(function(it){
            return result[it];
          })(
          ['reqStr', 'reqDex', 'reqInt', 'reqFai'])), result.atk = join('/')(
          map(function(it){
            return Math.floor(result[it]);
          })(
          ['atkPhy', 'atkMag', 'atkFir', 'atkLit'])), result.def = join('/')(
          map(function(it){
            return Math.floor(result[it]);
          })(
          this$._itemSvc.constructor.DefenceTypes)), result.dps = join('/')(
          result.dps) + " (" + result.atkCost + ")", result;
        })(
        results);
        this$.$scope.gridOptions.data = this$.$scope.results;
      });
    };
    return WeaponFinderController;
  }());
  if (typeof module != 'undefined' && module !== null) {
    module.exports = WeaponFinderController;
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);

},{"./config/weapon-finder-grid-options":38}],42:[function(require,module,exports){
(function(){
  var WeaponFinderService;
  if (typeof angular != 'undefined' && angular !== null) {
    angular.module("dsc").service("weaponFinderSvc", function(itemSvc, inventorySvc, statSvc, $q){
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t;
        return (t = typeof result)  == "object" || t == "function" ? result || child : child;
  })(WeaponFinderService, arguments, function(){});
    });
  }
  WeaponFinderService = (function(){
    WeaponFinderService.displayName = 'WeaponFinderService';
    var prototype = WeaponFinderService.prototype, constructor = WeaponFinderService;
    function WeaponFinderService(_itemSvc, _inventorySvc, _statSvc, $q){
      var this$ = this;
      this._itemSvc = _itemSvc;
      this._inventorySvc = _inventorySvc;
      this._statSvc = _statSvc;
      this.$q = $q;
      this.calculateScoreFor = bind$(this, 'calculateScoreFor', prototype);
      this.findFittingWeaponsIn = bind$(this, 'findFittingWeaponsIn', prototype);
      this.findFittingWeapons = bind$(this, 'findFittingWeapons', prototype);
      this.findBestWeapons = bind$(this, 'findBestWeapons', prototype);
      this.params = {
        useDps: false,
        dpsCalcMove: 0,
        includeUpgrades: true,
        modifiers: {},
        reqLimits: {}
      };
      this.statArray = this._itemSvc.constructor.AttackTypes.concat(this._itemSvc.constructor.DefenceTypes);
      each(function(it){
        this$.params.reqLimits[it] = 20;
      })(
      this._itemSvc.constructor.WeaponStats);
      each(function(it){
        this$.params.modifiers[it] = 0;
      })(
      this.statArray);
      this.params.modifiers['atkPhy'] = 1;
    }
    prototype.findBestWeapons = function(){
      var allWeapons, this$ = this;
      allWeapons = [];
      return this.findFittingWeapons().then(function(weapons){
        allWeapons = allWeapons.concat(weapons);
        if (!this$.params.includeUpgrades) {
          return [];
        }
        return this$.$q.all(map(function(it){
          return this$._inventorySvc.findAllAvailableUpgradesFor(it);
        })(
        weapons));
      }).then(function(upWeapons){
        allWeapons = allWeapons.concat(flatten(
        reject(function(it){
          return empty(
          it);
        })(
        upWeapons)));
        return map(this$.calculateScoreFor)(
        allWeapons);
      });
    };
    prototype.findFittingWeapons = function(){
      var this$ = this;
      return this._inventorySvc.findItemsByType('weapon').then(function(list){
        return this$.findFittingWeaponsIn(list);
      });
    };
    prototype.findFittingWeaponsIn = function(weaponList){
      var fitWeapons, statKeys, reqKeys, statValues, i$, len$, weapon, fit, j$, len1$, a, key;
      fitWeapons = [];
      statKeys = ['str', 'dex', 'int', 'fai'];
      reqKeys = ['reqStr', 'reqDex', 'reqInt', 'reqFai'];
      statValues = {};
      for (i$ = 0, len$ = weaponList.length; i$ < len$; ++i$) {
        weapon = weaponList[i$];
        fit = true;
        for (j$ = 0, len1$ = statKeys.length; j$ < len1$; ++j$) {
          a = j$;
          key = statKeys[j$];
          if (this.params.reqLimits[key] == null) {
            continue;
          }
          if (weapon[reqKeys[a]] > this.params.reqLimits[key]) {
            fit = false;
            break;
          }
        }
        if (fit) {
          fitWeapons.push(weapon);
        }
      }
      return this.$q.when(fitWeapons);
    };
    prototype.calculateScoreFor = function(weapon){
      var result, scS, scD, scI, scF, x$, i$, ref$, len$, index, statName, stat, this$ = this;
      result = import$({}, weapon);
      scS = this._statSvc.statScalingFactorOf('str');
      scD = this._statSvc.statScalingFactorOf('dex');
      scI = this._statSvc.statScalingFactorOf('int');
      scF = this._statSvc.statScalingFactorOf('fai');
      x$ = result;
      x$.atkPhy *= 1 + (weapon.bonusStr * scS + weapon.bonusDex * scD);
      x$.atkMag *= 1 + (weapon.bonusInt * scI + weapon.bonusFai * scF);
      x$.atkCost = result.atkCosts[this.params.dpsCalcMove];
      x$.dps = map(function(it){
        var ref$;
        if (result[it] < 1) {
          return 0;
        } else {
          return Math.floor(result[it] / ((ref$ = x$.atkCost) != null
            ? ref$
            : result[it]));
        }
      })(
      this._itemSvc.constructor.AttackTypes);
      if (result.weaponType === 'Magic') {
        x$.dps[0] = x$.dps[1] = 0;
      }
      x$.score = 0;
      for (i$ = 0, len$ = (ref$ = this.statArray).length; i$ < len$; ++i$) {
        index = i$;
        statName = ref$[i$];
        if (this.params.useDps && this._itemSvc.constructor.DpsTypes[index] != null) {
          stat = result.dps[index];
        } else {
          stat = result[statName];
        }
        result.score += stat * this.params.modifiers[statName];
      }
      return result;
    };
    return WeaponFinderService;
  }());
  if (typeof module != 'undefined' && module !== null) {
    module.exports = WeaponFinderService;
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);

},{}]},{},[1]);
